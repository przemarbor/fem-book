<!--
File automatically generated using DocOnce (https://github.com/doconce/doconce/):
doconce format html approx.do.txt --html_style=bloodish --html_output=approx-1 -DWITH_TOC
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices,finite element, definition,dof map,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,Midpoint rule,Trapezoidal rule,Simpson's rule,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,isoparametric mapping,mapping of reference cells isoparametric mapping">
<title></title>
<style type="text/css">
/* bloodish style */
body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em; color: #8A0808; }
h2 { font-size: 1.6em; color: #8A0808; }
h3 { font-size: 1.4em; color: #8A0808; }
h4 { font-size: 1.2em; color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa; }div.highlight {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    line-height: 1.21429em;
}
div.cell {
    width: 100%;
    padding: 5px 5px 5px 0;
    margin: 0;
    outline: none;
}
div.input {
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.inner_cell {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    box-flex: 1;
    flex: 1;
}
div.input_area {
    border: 1px solid #cfcfcf;
    border-radius: 4px;
    background: #f7f7f7;
    line-height: 1.21429em;
}
div.input_area > div.highlight {
    margin: .4em;
    border: none;
    padding: 0;
    background-color: transparent;
}
div.output_wrapper {
    position: relative;
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
.output {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
div.output_area {
    padding: 0;
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.output_subarea {
    padding: .4em .4em 0 .4em;
    box-flex: 1;
    flex: 1;
}
div.output_text {
    text-align: left;
    color: #000;
    line-height: 1.21429em;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.githubusercontent.com/doconce/doconce/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://raw.githubusercontent.com/doconce/doconce/main/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://raw.githubusercontent.com/doconce/doconce/main/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://raw.githubusercontent.com/doconce/doconce/main/bundled/html_images/small_gray_question.png); }
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Wstęp', 1, None, 'wst&#281;p'),
              ('Ta prezentacja', 3, None, 'ta-prezentacja'),
              ('Kody Pythona', 3, None, 'kody-pythona'),
              ('Hans Petter Langtangen (1962-2016)',
               3,
               None,
               'hans-petter-langtangen-1962-2016'),
              ('Metoda elementów skończonych - wstęp',
               1,
               None,
               'metoda-element&#243;w-sko&#324;czonych-wst&#281;p'),
              ('Delfin', 2, None, 'delfin'),
              ('Rozwiązywanie $\\PDE$ przy pomocy FEM',
               2,
               None,
               'rozwi&#261;zywanie-pde-przy-pomocy-fem'),
              ('Etapy nauki FEM', 2, None, 'etapy-nauki-fem'),
              ('Aproksymacja w przestrzeniach wektorowych',
               1,
               None,
               'aproksymacja-w-przestrzeniach-wektorowych'),
              ('Aproksymacja jako kombinacja liniowa założonych funkcji '
               'bazowych',
               2,
               None,
               'aproksymacja-jako-kombinacja-liniowa-za&#322;o&#380;onych-funkcji-bazowych'),
              ('Trzy główne sposoby wyznaczania niewiadomych współczynników',
               2,
               None,
               'trzy-g&#322;&#243;wne-sposoby-wyznaczania-niewiadomych-wsp&#243;&#322;czynnik&#243;w'),
              ('Aproksymacja wektorów: przykład -- aproksymacja na '
               'płaszczyznie',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('Wektory 2D - rzut ortogonalny',
               2,
               'fem:approx:vec:plane:ortho:proj',
               'fem:approx:vec:plane:ortho:proj'),
              ('Aproksymacja wektorów: przestrzenie wektorowe -- terminologia',
               2,
               None,
               'aproksymacja-wektor&#243;w-przestrzenie-wektorowe-terminologia'),
              ('Metoda najmniejszych kwadratów - idea',
               2,
               None,
               'metoda-najmniejszych-kwadrat&#243;w-idea'),
              ('Metoda najmniejszych kwadratów - obliczenia',
               2,
               None,
               'metoda-najmniejszych-kwadrat&#243;w-obliczenia'),
              ('Metoda rzutu ortogonalnego (m. Galerkina)',
               2,
               None,
               'metoda-rzutu-ortogonalnego-m-galerkina'),
              ('Aproksymacja wektora przestrzeni dowolniewymiarowej',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('Metoda najmniejszych kwadratów',
               2,
               None,
               'metoda-najmniejszych-kwadrat&#243;w'),
              ('Metoda Galerkina', 2, None, 'metoda-galerkina'),
              ('Aproksymacja funkcji w przestrzeni funkcyjnej',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('Uogólnienie $\\LSM$ na przestrzenie funkcyjne',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('Szczegóły $\\LSM$', 2, None, 'szczeg&#243;&#322;y-lsm'),
              ('Metoda Galerkina', 2, None, 'metoda-galerkina'),
              ('Przykład: aproksymacja paraboli funkcją liniową',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Przykład: aproksymacja paraboli funkcją liniową',
               2,
               None,
               'przyk&#322;ad-aproksymacja-paraboli-funkcj&#261;-liniow&#261;'),
              ('Przykład: aproksymacja paraboli funkcją liniową',
               2,
               None,
               'przyk&#322;ad-aproksymacja-paraboli-funkcj&#261;-liniow&#261;'),
              ('Symboliczna realizacja algorytmu $\\LSM$',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('$\\LSM$ symbolicznie:  podejście nr 1',
               2,
               None,
               'lsm-symbolicznie-podej&#347;cie-nr-1'),
              ('$\\LSM$ symbolicznie:  podejście nr 2',
               2,
               None,
               'lsm-symbolicznie-podej&#347;cie-nr-2'),
              ('Prezentacja rozwiązania',
               2,
               None,
               'prezentacja-rozwi&#261;zania'),
              ('Zastosowanie kodu', 2, None, 'zastosowanie-kodu'),
              ('Przypadek aproksymacji funkcji $f\\in V$',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Uogólnienie: Przypadek aproksymacji funkcji $f\\in V$',
               2,
               None,
               'uog&#243;lnienie-przypadek-aproksymacji-funkcji-f-in-v'),
              ('Dlaczego dla $f\\in V$ aproksymacja jest bezbłędna? Dowód:',
               2,
               None,
               'dlaczego-dla-f-in-v-aproksymacja-jest-bezb&#322;&#281;dna-dow&#243;d'),
              ('Skończona precyzja obliczeń numerycznych',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Skończona prezycja obliczeń numerycznych -- wyniki',
               2,
               None,
               'sko&#324;czona-prezycja-oblicze&#324;-numerycznych-wyniki'),
              ("Złe uwarunkowanie URL - ''liniowa zależność'' w bazie",
               2,
               None,
               'z&#322;e-uwarunkowanie-url-liniowa-zale&#380;no&#347;&#263;-w-bazie'),
              ('Złe uwarunkowanie URL: wnioski',
               2,
               None,
               'z&#322;e-uwarunkowanie-url-wnioski'),
              ('Aproksymacja szeregami Fouriera; problem and code',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Aproksymacja szeregami Fouriera; wykres',
               2,
               None,
               'aproksymacja-szeregami-fouriera-wykres'),
              ('Aproksymacja szeregami Fouriera; ulepszenie',
               2,
               None,
               'aproksymacja-szeregami-fouriera-ulepszenie'),
              ('Aproksymacja szeregami Fouriera; wyniki',
               2,
               None,
               'aproksymacja-szeregami-fouriera-wyniki'),
              ('Bazy funkcji ortogonalnych',
               2,
               None,
               'bazy-funkcji-ortogonalnych'),
              ('Implementacja $\\LSM$ dla ortogonalnych funkcji bazowych',
               2,
               None,
               'implementacja-lsm-dla-ortogonalnych-funkcji-bazowych'),
              ('Implementacja $\\LSM$ dla ortogonalnych funkcji bazowych: '
               'całkowanie symboliczne i numeryczne',
               2,
               None,
               'implementacja-lsm-dla-ortogonalnych-funkcji-bazowych-ca&#322;kowanie-symboliczne-i-numeryczne'),
              ('Metoda kolokacji (interpolacji); idea i teoria',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Metoda kolokacji -- implementacja',
               2,
               None,
               'metoda-kolokacji-implementacja'),
              ('Metoda kolokacji: przybliżenie paraboli funkcją liniową',
               2,
               None,
               'metoda-kolokacji-przybli&#380;enie-paraboli-funkcj&#261;-liniow&#261;'),
              ('Regresja',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Regresja -- nadokreślone URL',
               2,
               None,
               'regresja-nadokre&#347;lone-url'),
              ('Rozwiązywanie nadokreślonych URL przy pomocy $\\LSM$',
               2,
               None,
               'rozwi&#261;zywanie-nadokre&#347;lonych-url-przy-pomocy-lsm'),
              ('Implementacja', 2, None, 'implementacja'),
              ('Przykład zastosowania -- kod',
               2,
               None,
               'przyk&#322;ad-zastosowania-kod'),
              ('Przykład zastosowania -- wyniki',
               2,
               None,
               'przyk&#322;ad-zastosowania-wyniki'),
              ("Wielomiany Lagrange'a",
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ("Wielomiany Lagrange'a -- wzór i implementacja",
               2,
               None,
               'wielomiany-lagrange-a-wz&#243;r-i-implementacja'),
              ("Wielomiany Lagrange'a -- zachęcający przykład zastosowania",
               2,
               None,
               'wielomiany-lagrange-a-zach&#281;caj&#261;cy-przyk&#322;ad-zastosowania'),
              ("Wielomiany Lagrange'a -- mniej zachęcający przykład "
               'zastosowania',
               2,
               None,
               'wielomiany-lagrange-a-mniej-zach&#281;caj&#261;cy-przyk&#322;ad-zastosowania'),
              ("Wielomiany Lagrange'a -- efekt Runge'go",
               2,
               None,
               'wielomiany-lagrange-a-efekt-runge-go'),
              ("Wielomiany Lagrange'a: jak zapobiec oscylacjom?",
               2,
               None,
               'wielomiany-lagrange-a-jak-zapobiec-oscylacjom'),
              ("Wielomiany Lagrange'a + węzły Czebyszewa",
               2,
               None,
               'wielomiany-lagrange-a-w&#281;z&#322;y-czebyszewa'),
              ("Wielomiany Lagrange'a + węzły Czebyszewa",
               2,
               None,
               'wielomiany-lagrange-a-w&#281;z&#322;y-czebyszewa'),
              ('Funkcje bazowe elementów skończonych',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Funkcje bazowe o nośniku nieograniczonym: $\\baspsi_i(x) \\neq '
               '0$ prawie w całym przedziale określoności',
               2,
               None,
               'funkcje-bazowe-o-no&#347;niku-nieograniczonym-baspsi-i-x-neq-0-prawie-w-ca&#322;ym-przedziale-okre&#347;lono&#347;ci'),
              ('Funkcje bazowe o nośniku ograniczonym -- $\\FEM$',
               2,
               None,
               'funkcje-bazowe-o-no&#347;niku-ograniczonym-fem'),
              ('Kombinacja liniowa funkcji trójkątnych',
               2,
               None,
               'kombinacja-liniowa-funkcji-tr&#243;jk&#261;tnych'),
              ('Elementy i węzły',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Przykład: obszar podzielony na elementy dwuwęzłowe (elementy '
               'typu P1)',
               2,
               None,
               'przyk&#322;ad-obszar-podzielony-na-elementy-dwuw&#281;z&#322;owe-elementy-typu-p1'),
              ('Przykład: dwie funkcje bazowe na siatce',
               2,
               None,
               'przyk&#322;ad-dwie-funkcje-bazowe-na-siatce'),
              ('Przykład: elementy niejednorodne o trzech węzłach (elementy '
               'typu P2)',
               2,
               None,
               'przyk&#322;ad-elementy-niejednorodne-o-trzech-w&#281;z&#322;ach-elementy-typu-p2'),
              ('Przykład: funkcje bazowe na siatce (elementy typu P2)',
               2,
               None,
               'przyk&#322;ad-funkcje-bazowe-na-siatce-elementy-typu-p2'),
              ('Przykład: elementy typu P3 (o czterech węzłach interpolacji)',
               2,
               None,
               'przyk&#322;ad-elementy-typu-p3-o-czterech-w&#281;z&#322;ach-interpolacji'),
              ('Przykład: funkcje bazowe na siatce (elementy typu P3)',
               2,
               None,
               'przyk&#322;ad-funkcje-bazowe-na-siatce-elementy-typu-p3'),
              ('Indeksacja nieregularna', 2, None, 'indeksacja-nieregularna'),
              ('Współczynniki $c_i$ -- interpretacja',
               2,
               None,
               'wsp&#243;&#322;czynniki-c-i-interpretacja'),
              ('Własności funkcji bazowych',
               2,
               None,
               'w&#322;asno&#347;ci-funkcji-bazowych'),
              ('Konstrukcja kwadratowych $\\basphi_i$ (elementy typu P2)',
               2,
               None,
               'konstrukcja-kwadratowych-basphi-i-elementy-typu-p2'),
              ('Liniowe $\\basphi_i$ (elementy typu P1)',
               2,
               None,
               'liniowe-basphi-i-elementy-typu-p1'),
              ('Sześcienne $\\basphi_i$ (elementy typu P3)',
               2,
               None,
               'sze&#347;cienne-basphi-i-elementy-typu-p3'),
              ('Generowanie URL',
               1,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Przykład 1: Obliczenie wartości (niediagonalnego) elementu '
               'macierzy',
               2,
               None,
               'przyk&#322;ad-1-obliczenie-warto&#347;ci-niediagonalnego-elementu-macierzy'),
              ('Przykład 2: Obliczenie wartości (diagonalnego) elementu '
               'macierzy',
               2,
               None,
               'przyk&#322;ad-2-obliczenie-warto&#347;ci-diagonalnego-elementu-macierzy'),
              ('Ogólna postać wzoru na wartość elementu $A_{ij}$ - rysunek',
               2,
               None,
               'og&#243;lna-posta&#263;-wzoru-na-warto&#347;&#263;-elementu-a-ij-rysunek'),
              ('Ogólna postać wzoru na wartość elementu $A_{ij}$ - obliczenia',
               2,
               None,
               'og&#243;lna-posta&#263;-wzoru-na-warto&#347;&#263;-elementu-a-ij-obliczenia'),
              ('Obliczenia dla prawej strony równania',
               2,
               None,
               'obliczenia-dla-prawej-strony-r&#243;wnania'),
              ('Przykład: rozwiązanie dla obszaru dwu-elementowego -- URL i '
               'rozwiązanie',
               2,
               None,
               'przyk&#322;ad-rozwi&#261;zanie-dla-obszaru-dwu-elementowego-url-i-rozwi&#261;zanie'),
              ('Przykład: rozwiązanie dla obszaru dwu-elementowego -- '
               'rozwiązanie-rysunek',
               2,
               None,
               'przyk&#322;ad-rozwi&#261;zanie-dla-obszaru-dwu-elementowego-rozwi&#261;zanie-rysunek'),
              ('Przykład: Rozwiązanie dla obszaru 4-elementowego -- '
               'rozwiązanie-rysunek',
               2,
               None,
               'przyk&#322;ad-rozwi&#261;zanie-dla-obszaru-4-elementowego-rozwi&#261;zanie-rysunek'),
              ('Przykład: elementy typu P2',
               2,
               None,
               'przyk&#322;ad-elementy-typu-p2'),
              ('Generowanie macierzy globalnej - logika obliczeń',
               1,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('Całkowanie z perspektywy elementu',
               2,
               None,
               'ca&#322;kowanie-z-perspektywy-elementu'),
              ('Macierz elementów: indeksacja lokalna/indeksacja globalna',
               2,
               None,
               'macierz-element&#243;w-indeksacja-lokalna-indeksacja-globalna'),
              ('Przykład: assembling macierzy dla kolejno ponumerowanych '
               'elementów P1',
               2,
               None,
               'przyk&#322;ad-assembling-macierzy-dla-kolejno-ponumerowanych-element&#243;w-p1'),
              ('Przykład: assembling macierzy dla kolejno ponumerowanych '
               'elementów P3',
               2,
               None,
               'przyk&#322;ad-assembling-macierzy-dla-kolejno-ponumerowanych-element&#243;w-p3'),
              ('Przykład: assembling macierzy dla nieregularnej siatki '
               'elementów P1',
               2,
               None,
               'przyk&#322;ad-assembling-macierzy-dla-nieregularnej-siatki-element&#243;w-p1'),
              ('Assembling prawej strony układu',
               2,
               None,
               'assembling-prawej-strony-uk&#322;adu'),
              ('Transformacja współrzędnych globalnych do współrzędnych '
               'unormowanych',
               1,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('Transformacja liniowa $X\\in [-1,1]$ w $x\\in [x_L,x_R]$',
               2,
               None,
               'transformacja-liniowa-x-in-1-1-w-x-in-x-l-x-r'),
              ('Transformacja całki', 2, None, 'transformacja-ca&#322;ki'),
              ('Zalety całkowania na przedziale unormowanym',
               2,
               None,
               'zalety-ca&#322;kowania-na-przedziale-unormowanym'),
              ('Funkcje bazowe P1 na elemencie unormowanym',
               2,
               None,
               'funkcje-bazowe-p1-na-elemencie-unormowanym'),
              ('Funkcje bazowe P2 na elemencie unormowanym',
               2,
               None,
               'funkcje-bazowe-p2-na-elemencie-unormowanym'),
              ('Sposoby znalezienia wzorów na funkcje bazowe',
               2,
               None,
               'sposoby-znalezienia-wzor&#243;w-na-funkcje-bazowe'),
              ('Całkowanie po elemencie unormowanym - lokalna macierz',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Całkowanie po elemencie unormowanym - wektor prawej strony',
               2,
               None,
               'ca&#322;kowanie-po-elemencie-unormowanym-wektor-prawej-strony'),
              ('Obliczenia symboliczne zamiast żmudnego liczenia na kartce...',
               2,
               None,
               'obliczenia-symboliczne-zamiast-&#380;mudnego-liczenia-na-kartce'),
              ('Implementacja', 1, None, 'implementacja'),
              ('Generowanie funkcji bazowych na przedziale unormowanymi',
               2,
               None,
               'generowanie-funkcji-bazowych-na-przedziale-unormowanymi'),
              ('Obliczanie współczynników macierzy',
               2,
               None,
               'obliczanie-wsp&#243;&#322;czynnik&#243;w-macierzy'),
              ('Przykład: Obliczenia macierzy współczynników: symbolicznie vs '
               'numerycznie',
               2,
               None,
               'przyk&#322;ad-obliczenia-macierzy-wsp&#243;&#322;czynnik&#243;w-symbolicznie-vs-numerycznie'),
              ('Obliczenia współczynników wektora prawej strony',
               2,
               None,
               'obliczenia-wsp&#243;&#322;czynnik&#243;w-wektora-prawej-strony'),
              ('Powrót do całkowania numerycznego w razie niepowodzenia '
               'całkowania symbolicznego $\\int f\\refphi_r dx$',
               2,
               None,
               'powr&#243;t-do-ca&#322;kowania-numerycznego-w-razie-niepowodzenia-ca&#322;kowania-symbolicznego-int-f-refphi-r-dx'),
              ('Assembling URL i rozwiązanie',
               2,
               None,
               'assembling-url-i-rozwi&#261;zanie'),
              ('Rozwiązanie URL', 2, None, 'rozwi&#261;zanie-url'),
              ('Przykład: generowanie macierzy symbolicznie',
               2,
               None,
               'przyk&#322;ad-generowanie-macierzy-symbolicznie'),
              ('Przykład: generowanie macierzy numerycznie',
               2,
               None,
               'przyk&#322;ad-generowanie-macierzy-numerycznie'),
              ('Struktura macierzy współczynników',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Wynik w przypadku ogólnym ($N$ jednakowych elementów)',
               2,
               None,
               'wynik-w-przypadku-og&#243;lnym-n-jednakowych-element&#243;w'),
              ('Macierz rzadka  dla elementów typu P2 (siatka regularna)',
               2,
               None,
               'macierz-rzadka-dla-element&#243;w-typu-p2-siatka-regularna'),
              ('Macierz rzadka dla siatek regularnych/indeksowanych losowo dla '
               'elementów P1',
               2,
               None,
               'macierz-rzadka-dla-siatek-regularnych-indeksowanych-losowo-dla-element&#243;w-p1'),
              ('Macierz rzadka dla siatek regularnych/indeksowanych losowo dla '
               'elementów P3',
               2,
               None,
               'macierz-rzadka-dla-siatek-regularnych-indeksowanych-losowo-dla-element&#243;w-p3'),
              ('Macierze rzadkie -- podsumowanie',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Przykład: przybliżenie funkcji $f\\sim x^9$ elementami różnego '
               'typu; kod',
               2,
               None,
               'przyk&#322;ad-przybli&#380;enie-funkcji-f-sim-x-9-elementami-r&#243;&#380;nego-typu-kod'),
              ('Przykład: przybliżenie funkcji $f\\sim x^9$ elementami różnego '
               'typu; rysunki',
               2,
               None,
               'przyk&#322;ad-przybli&#380;enie-funkcji-f-sim-x-9-elementami-r&#243;&#380;nego-typu-rysunki'),
              ('Ograniczenia zaprezentowanego podejścia elementów skończonych',
               1,
               'fem:approx:fe:limitations',
               'fem:approx:fe:limitations'),
              ('Uogólnienie koncepcji elementu skończonego (komórki, '
               'wierzchołki, węzły, stopnie swobody)',
               2,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Pojęcie elementu skończonego',
               2,
               None,
               'poj&#281;cie-elementu-sko&#324;czonego'),
              ('Struktury danych: `vertices`, `cells`, `dof_map`',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Przykład: elementy P0', 2, None, 'przyk&#322;ad-elementy-p0'),
              ('Szkielet programu', 2, None, 'szkielet-programu'),
              ('Przybliżenie paraboli elementami P0',
               2,
               None,
               'przybli&#380;enie-paraboli-elementami-p0'),
              ('Obliczanie błędów aproksymacji; uwagi ogólne',
               2,
               'fem:approx:fe:element:impl:error',
               'fem:approx:fe:element:impl:error'),
              ('Obliczanie błędów aproksymacji; szczegóły',
               2,
               None,
               'obliczanie-b&#322;&#281;d&#243;w-aproksymacji-szczeg&#243;&#322;y'),
              ('Zależność błędu od $h$ i $d$',
               2,
               None,
               'zale&#380;no&#347;&#263;-b&#322;&#281;du-od-h-i-d'),
              ("Kubiczne wielomiany Hermite'a - definicja",
               2,
               None,
               'kubiczne-wielomiany-hermite-a-definicja'),
              ("Kubiczne wielomiany Hermite'a - wyprowadzenie",
               2,
               None,
               'kubiczne-wielomiany-hermite-a-wyprowadzenie'),
              ("Kubiczne wielomiany Hermite'a - wynik",
               2,
               None,
               'kubiczne-wielomiany-hermite-a-wynik'),
              ("Kubiczne wielomiany Hermite'a - sprawdzenie",
               2,
               None,
               'kubiczne-wielomiany-hermite-a-sprawdzenie'),
              ("Kubiczne wielomiany Hermite'a - sprawdzenie",
               2,
               None,
               'kubiczne-wielomiany-hermite-a-sprawdzenie'),
              ("Kubiczne wielomiany Hermite'a - wyniki",
               2,
               None,
               'kubiczne-wielomiany-hermite-a-wyniki'),
              ('Całkowanie numeryczne', 1, None, 'ca&#322;kowanie-numeryczne'),
              ('Ogólna postać kwadratury',
               2,
               None,
               'og&#243;lna-posta&#263;-kwadratury'),
              ('Wzór prostokątów', 2, None, 'wz&#243;r-prostok&#261;t&#243;w'),
              ('Metody Newtona-Cotesa',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ("Metoda Gaussa-Legendre'a", 2, None, 'metoda-gaussa-legendre-a'),
              ('Aproksymacja funkcji w 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('Krótkie omówienie zagadnienia w 2D',
               2,
               None,
               'kr&#243;tkie-om&#243;wienie-zagadnienia-w-2d'),
              ('Funkcje bazowe 2D jako iloczyn tensorowy funkcji 1D',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Iloczyn tensorowy', 2, None, 'iloczyn-tensorowy'),
              ('Równoważność notacji z dwoma lub jednym indeksem',
               2,
               None,
               'r&#243;wnowa&#380;no&#347;&#263;-notacji-z-dwoma-lub-jednym-indeksem'),
              ('Przykładowa baza przestrzeni 2D; wzory',
               2,
               None,
               'przyk&#322;adowa-baza-przestrzeni-2d-wzory'),
              ('Przykładowa baza przestrzeni 2D; zastosowanie',
               2,
               None,
               'przyk&#322;adowa-baza-przestrzeni-2d-zastosowanie'),
              ('Implementacja; principal changes to the 1D code',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Implementacja 2D: całkowanie',
               2,
               None,
               'implementacja-2d-ca&#322;kowanie'),
              ('Implementacja 2D: funkcje bazowe',
               2,
               None,
               'implementacja-2d-funkcje-bazowe'),
              ('Implementacja 2D: zastosowanie',
               2,
               None,
               'implementacja-2d-zastosowanie'),
              ('Implementacja 2D: przykład zastosowanie bazy umożliwiającej '
               'konstrukcję rozwiązania dokładnego',
               2,
               None,
               'implementacja-2d-przyk&#322;ad-zastosowanie-bazy-umo&#380;liwiaj&#261;cej-konstrukcj&#281;-rozwi&#261;zania-dok&#322;adnego'),
              ('Uogólnienie do zagadnień 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Elementy skończone w 2D i 3D',
               1,
               None,
               'elementy-sko&#324;czone-w-2d-i-3d'),
              ('Przykłady komórek 2D i 3D',
               2,
               None,
               'przyk&#322;ady-kom&#243;rek-2d-i-3d'),
              ('Obszar prostokątny (2D) zbudowany z elementów typu P1',
               2,
               None,
               'obszar-prostok&#261;tny-2d-zbudowany-z-element&#243;w-typu-p1'),
              ('Nieregularny obszar 2D zbudowany z elementów typu P1',
               2,
               None,
               'nieregularny-obszar-2d-zbudowany-z-element&#243;w-typu-p1'),
              ('Obszar prostokątny (2D) zbudowany z elementów typu Q1',
               2,
               None,
               'obszar-prostok&#261;tny-2d-zbudowany-z-element&#243;w-typu-q1'),
              ('Aproksymacja funkcji 2D na siatce elementów trójkątnych',
               2,
               None,
               'aproksymacja-funkcji-2d-na-siatce-element&#243;w-tr&#243;jk&#261;tnych'),
              ('Własności elementów 2D typu P1',
               2,
               None,
               'w&#322;asno&#347;ci-element&#243;w-2d-typu-p1'),
              ('Odwzorowanie liniowe elementu unormowanego na komórkę '
               'trójkątną',
               2,
               None,
               'odwzorowanie-liniowe-elementu-unormowanego-na-kom&#243;rk&#281;-tr&#243;jk&#261;tn&#261;'),
              ('$\\basphi_i$: funkcja-piramida',
               2,
               None,
               'basphi-i-funkcja-piramida'),
              ('Elementy macierzy i wektora prawej strony',
               2,
               None,
               'elementy-macierzy-i-wektora-prawej-strony'),
              ('Funkcje bazowe na unormowanym elemencie trójkątnym',
               2,
               None,
               'funkcje-bazowe-na-unormowanym-elemencie-tr&#243;jk&#261;tnym'),
              ('Elementy trójkątne typu P1, P2, P3, P4, P5, P6 przestrzeni 2D',
               2,
               None,
               'elementy-tr&#243;jk&#261;tne-typu-p1-p2-p3-p4-p5-p6-przestrzeni-2d'),
              ('Elementy P1 przestrzeni 1D, 2D i 3D',
               2,
               None,
               'elementy-p1-przestrzeni-1d-2d-i-3d'),
              ('Elementy P2 przestrzeni 1D, 2D i 3D',
               2,
               None,
               'elementy-p2-przestrzeni-1d-2d-i-3d'),
              ('Odwzorowanie afiniczne komórki unormowanej -- wzór',
               2,
               None,
               'odwzorowanie-afiniczne-kom&#243;rki-unormowanej-wz&#243;r'),
              ('Odwzorowanie afiniczne komórki unormowanej',
               2,
               None,
               'odwzorowanie-afiniczne-kom&#243;rki-unormowanej'),
              ('Komórki izoparametryczne',
               2,
               None,
               'kom&#243;rki-izoparametryczne'),
              ('Obliczanie całek', 2, None, 'obliczanie-ca&#322;ek'),
              ('Uwaga dot. uogólnienia FEM z 1D do 2D/3D',
               2,
               None,
               'uwaga-dot-uog&#243;lnienia-fem-z-1d-do-2d-3d')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\PDE}{\mathrm{RRCz}}
\newcommand{\FEM}{\mathrm{FEM}}
\newcommand{\LSM}{\mathrm{MNK}}
$$



<!-- ------------------- main content ---------------------- -->
<!-- 2DO: -->
<!-- Less 7= headings (or: ok when approx and varform are split?) -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="wst&#281;p">Wst&#281;p </h1>
<h3 id="ta-prezentacja">Ta prezentacja </h3>
<ul>
   <p><li> <a href="http://marbor.strony.prz.edu.pl/download/FEM/pdf/approx-beamer.pdf" target="_self">PDF</a></li>
   <p><li> <a href="http://marbor.strony.prz.edu.pl/download/FEM/html/pages/approx-1.html" target="_self">HTML (jasny)</a></li>
   <p><li> <a href="http://marbor.strony.prz.edu.pl/download/FEM/html/pages/approx-reveal.html" target="_self">reveal (jasny)</a></li>
   <p><li> <a href="http://marbor.strony.prz.edu.pl/download/FEM/html/pages/approx-reveal-dark.html" target="_self">reveal (ciemny)</a></li>
   <p><li> <a href="http://marbor.strony.prz.edu.pl/download/FEM/html/pages/approx-deck.html" target="_self">deck.js (jasny)</a></li>
</ul>
<h3 id="kody-pythona">Kody Pythona </h3>
<a href="https://github.com/przemarbor/fem-book/tree/master/doc/.src/book/src" target="_self">Repozytorium</a>
<h3 id="hans-petter-langtangen-1962-2016">Hans Petter Langtangen (1962-2016) </h3>

<ul>
 <p><li> <a href="https://hplgit.github.io/homepage/index.html" target="_self">Strona domowa</a></li>
 <p><li> <a href="https://github.com/hplgit" target="_self">Github</a></li>
 <p><li> <a href="https://doconce.github.io" target="_self">DocOnce i ksi&#261;&#380;ki HPL</a></li>
 <p><li> <a href="http://hplgit.github.io/fem-book/doc/web/index.html" target="_self">Ksi&#261;&#380;ka o FEM (EN)</a></li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="metoda-element&#243;w-sko&#324;czonych-wst&#281;p">Metoda element&#243;w sko&#324;czonych - wst&#281;p </h1>

<p>Finite Element Method, FEM, MES</p>

<!-- !bslidecell 00 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 1</p>
</center>
<p><img src="../fig/dolfin_mesh.png" width="200" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !bslidecell 01 -->
<!-- !bpop -->
<ul>
 <p><li> pozwala rozwi&#261;zywa&#263; \( \PDE \) dla obszar&#243;w o z&#322;o&#380;onej geometrii</li>
 <p><li> pozwala ''regulowa&#263;'' dok&#322;adno&#347;&#263; siatki tam gdzie to potrzebne</li>
 <p><li> mo&#380;liwo&#347;&#263; u&#380;ycia aproksymacji wy&#380;szego rz&#281;du</li>
 <p><li> solidne, matematyczne podstawy -> mo&#380;liwo&#347;&#263; dok&#322;adnej analizy metody</li>
</ul>
<!-- !epop -->

<!-- !eslidecell -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="delfin">Delfin </h2>

<!-- !bslidecell 00 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 2</p>
</center>
<p><img src="../fig/dolfin_mesh.png" width="400" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !bslidecell 01 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 3</p>
</center>
<p><img src="../fig/dolfin_flow.gif" width="400" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="rozwi&#261;zywanie-pde-przy-pomocy-fem">Rozwi&#261;zywanie \( \PDE \) przy pomocy FEM </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Zagadnienia stacjonarne:</b>
<p>
<ol>
<p><li> Przekszta&#322;cenie zagadnienia brzegowego do <em>postaci wariacyjnej</em></li>
<p><li> Zdefiniowanie funkcji aproksymuj&#261;cych dla <em>element&#243;w sko&#324;czonych</em></li>
<p><li> Przkszta&#322;cenie zagadnienia ci&#261;g&#322;ego w dyskretne wyra&#380;one <em>uk&#322;adem r&#243;wna&#324; liniowych</em> (URL)</li>
<p><li> Rozwi&#261;zanie URL</li>
</ol>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>Zagadnienia niestacjonarne (zale&#380;ne od czasu):</b>
<p>
<ul>
 <p><li> MES - aproksymacja przestrzeni</li> 
 <p><li> FDM (lub metoda rozw. ODE) - aproksymacja w czasie</li>
</ul>
</div>


<!-- Give a brief example here, 1D or 2D -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="etapy-nauki-fem">Etapy nauki FEM </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Jak?</b>
<p>
<ol>
<p><li> Elementy teorii aproksymacji (nie zaczynamy od rozw. \( \PDE \)!)</li>
<p><li> Wst&#281;p do aproksymacji elementami sko&#324;czonymi</li>
<p><li> W ko&#324;cu zastosowanie powy&#380;szego do rozw. \( \PDE \)</li>
</ol>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b>Dlaczego tak?</b>
<p>
<p>Istnieje wiele wariant&#243;w i odmian \( \FEM \).
Dzi&#281;ki proponowanemu podej&#347;ciu &#322;atwiej si&#281; ''po&#322;apa&#263;''. Unikamy zamieszania
wielo&#347;ci&#261; podej&#347;&#263; do tematu, koncepcji i technicznych/implementacyjnych
szczeg&#243;&#322;&#243;w.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="aproksymacja-w-przestrzeniach-wektorowych">Aproksymacja w przestrzeniach wektorowych </h1>

<p>Jak znale&#378;&#263; wektor pewnej przestrzeni, kt&#243;ry aproksymuje
wektor przestrzeni o wi&#281;kszym wymiarze?
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 4</p>
</center>
<p><img src="../fig/vecapprox_plane.png" width="300" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="aproksymacja-jako-kombinacja-liniowa-za&#322;o&#380;onych-funkcji-bazowych">Aproksymacja jako kombinacja liniowa za&#322;o&#380;onych funkcji bazowych </h2>

<p>Og&#243;lna idea poszukiwania elementu (wektora/funkcji) \( u(x) \) pewnej przestrzeni przybli&#380;aj&#261;cego zadany element \( f(x) \):</p>

$$
u(x) = \sum_{i=0}^N c_I \baspsi_i(x)
$$

<p>gdzie</p>

<ul>
<p><li> \( \baspsi_i(x) \) za&#322;o&#380;one funkcje</li>
<p><li> \( c_i \), \( i=0,\ldots,N \) nieznane wsp&#243;&#322;czynniki (do wyznaczenia)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="trzy-g&#322;&#243;wne-sposoby-wyznaczania-niewiadomych-wsp&#243;&#322;czynnik&#243;w">Trzy g&#322;&#243;wne sposoby wyznaczania niewiadomych wsp&#243;&#322;czynnik&#243;w </h2>

<ul>
 <p><li> metoda najmniejszych kwadrat&#243;w (ang. Least Squares Method LSM)</li>
 <p><li> metoda Galerkina</li>
 <p><li> metoda kolokacji</li>
</ul>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Spos&#243;b opisu i notacja zaproponowane w materia&#322;ach
pozwalaj&#261; na (nieco) &#322;atwiejsze rozpocz&#281;cie pracy i zrozumienie
zasady dzia&#322;ania 
wybrane w spos&#243;b u&#322;atwiaj&#261;cy zrozumienie
open-source'owego pakietu <a href="http://fenicsproject.org" target="_self">FEniCS</a>
&ndash; biblioteki do oblicze&#324; metod&#261; element&#243;w sko&#324;czonych.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="aproksymacja-wektor&#243;w-przyk&#322;ad-ndash-aproksymacja-na-p&#322;aszczyznie">Aproksymacja wektor&#243;w: przyk&#322;ad &ndash; aproksymacja na p&#322;aszczyznie </h2>
<div id="fem:approx:vec:plane"></div>

<p>Zadanie:</p>

<p>Znajd&#378; przybli&#380;enie wektora \( \f = (3,5) \) wzd&#322;u&#380; zadanego kierunku.</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 5</p>
</center>
<p><img src="../fig/vecapprox_plane.png" width="300" align="bottom"></p>
</center>

<p>analogie: element - punkt - wektor - funkcja</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:vec:plane:ortho:proj">Wektory 2D - rzut ortogonalny</h2>

<!-- !bslidecell 00 0.2 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 6</p>
</center>
<p><img src="../figMB/orthopro_dotprod.png" width="300" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !bslidecell 01 0.75 -->

<ul>
<p><li> \( \frac{d}{||\v||} = \cos \alpha \)</li>
<p><li> \( d = ||\v|| \cos \alpha \)</li> 
</ul>
\( \quad \)

<ul>
<p><li> \( (\u,\v) = a_{1}b_{1} + a_{2}b_{2} + \ldots \)</li>
<p><li> \( (\u,\v) = ||\u||\cdot||\v||\cos\alpha \)</li>
<p><li> \( \frac{(\u,\v)}{||\u||} =||\v||\cos\alpha = d \)</li>
</ul>
\( \quad \)

<ul>
<p><li> \( (\u,\v) = 0  \) ->  \( \u \) i \( \v \) s&#261; prostopad&#322;e</li>
</ul>
<!-- !eslidecell -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="aproksymacja-wektor&#243;w-przestrzenie-wektorowe-ndash-terminologia">Aproksymacja wektor&#243;w: przestrzenie wektorowe &ndash; terminologia </h2>

$$ V = \mbox{span}\,\{ \psib_0\} $$


<ul>
 <p><li> \( \psib_0 \) wektor bazowy przestrzeni \( V \)</li>
 <p><li> Znajd&#378; \( \u = c_0\psib_0\in V \)</li>
 <p><li> Jak wyznaczy&#263; \( c_0 \) tak, aby \( \u \) "najlepiej" przybli&#380;a&#322;o \( \f \)?</li>
 <p><li> Wizualnie rozwi&#261;zanie narzuca si&#281; samo</li>
 <p><li> Jak sformu&#322;owa&#263; to og&#243;lnie, w j&#281;zyku matematyki?</li>
</ul>
<p>Niech</p>

<ul>
 <p><li> \( \e = \f - \u \) to b&#322;&#261;d</li>
 <p><li> \( (\u,\v) \) &ndash; iloczyn skalarny wektor&#243;w (-> sens geometryczny il.s. -> przyk&#322;ad?)</li>
 <p><li> \( ||\e|| = \sqrt{(\e, \e)} \) &ndash; norma b&#322;&#281;du (jaka? (normy \( p \)-te))</li>
</ul>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Uwaga:</b>
<p>
<p>\( (a,b) \) &ndash; punkt/wektor przestrzeni (dwuwymiarowej)</p>

<p>\( (\u,\v) \) &ndash; iloczyn skalarny dw&#243;ch wektor&#243;w przestrzeni (dowolnie-wymiarowej)</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-najmniejszych-kwadrat&#243;w-idea">Metoda najmniejszych kwadrat&#243;w - idea </h2>

<ul>
 <p><li> Idea: znale&#378;&#263; \( c_0 \) takie, aby \( ||\e|| \) by&#322; minimalizowany (jak najmniejszy/najkr&#243;tszy)</li>
 <p><li> Dla wygody (matematycznej): minimalizujemy \( E=||\e||^2 \)</li>
</ul>
$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\end{equation*}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-najmniejszych-kwadrat&#243;w-obliczenia">Metoda najmniejszych kwadrat&#243;w - obliczenia </h2>

$$
\begin{align*}
E(c_0) &= (\e,\e) = (\f - \u, \f - \u) = (\f - c_0\psib_0, \f - c_0\psib_0)\\ 
       &= (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)
\end{align*}
$$


$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0) = 0
\label{fem:vec:dEdc0:v1}
\end{equation}
$$


$$
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)} = \frac{3a + 5b}{a^2 + b^2}
$$

<p>Spostrze&#380;enie (na p&#243;&#378;niej): warunek znikania pochodnej \eqref{fem:vec:dEdc0:v1}
mo&#380;na r&#243;wnowa&#380;nie zapisa&#263; jako:
</p>
$$ (\e, \psib_0) = 0 $$


$$
(\e, \psib_0) = (\f - \u, \psib_0) = (\f, \psib_0) - (\u, \psib_0) ....
\quad\quad (*-2 ...)
$$

$$
[\f-\u] \cdot
\left[
\begin{array}{c}
 \\ 
\psib_0 \\ 
 \\ 
\end{array}
\right]
=
[\quad\quad \f \quad\quad] \cdot
\left[
\begin{array}{c}
 \\ 
\psib_0 \\ 
 \\ 
\end{array}
\right]
-
[\quad\quad \u \quad\quad] \cdot
\left[
\begin{array}{c}
 \\ 
\psib_0 \\ 
 \\ 
\end{array}
\right]
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-rzutu-ortogonalnego-m-galerkina">Metoda rzutu ortogonalnego (m. Galerkina) </h2>

<!-- !bslidecell 00 0.2 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 7</p>
</center>
<p><img src="../figMB/orthopro.png" width="300" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !bslidecell 01 0.75 -->
<!-- !bpop -->
<ul>
 <p><li> \( \min E \) $\rightarrow$ to samo co:  \( (\e, \psib_0)=0 \) (rysunek)</li>
 <p><li> \( (\e, \psib_0)=0 \) $\Rightarrow$ \( (\e, \v)=0 \) dla <em>dowolnego</em> \( \v\in V \) (rysunek)</li>
 <p><li> Czyli: zamiast korzysta&#263; z aproksymacji &#347;redniokwadratowej, mo&#380;na wymusi&#263;, aby \( \e \) by&#322;o ortogonalne (prostopad&#322;e) dla dowolnego \( \v\in V \) &ndash; oczywiste na rysunku ...</li>
 <p><li> ... a w j&#281;zyku matematyki: znajd&#378; takie \( c_0 \) aby \( (\e, \v) = 0,\quad\forall\v\in V \)</li>
 <p><li> R&#243;wnowa&#380;nie: znajd&#378; takie \( c_0 \) aby \( (\e, \psib_0)=0 \)</li>
 <p><li> Podstawmy: \( \e = \f - c_0\psib_0 \) i rozwi&#261;&#380;my ze wzgl&#281;du na \( c_0 \)</li>
 <p><li> Ostatecznie: to samo r&#243;wnanie (a wi&#281;c i to samo rozwi&#261;zanie) co w metodzie najmniejszych kwadrat&#243;w</li>
</ul>
<!-- !epop -->

<!-- !eslidecell -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:vec:Np1dim">Aproksymacja wektora przestrzeni dowolniewymiarowej</h2>

<p>Dla danego wektora \( \f \), znajd&#378; przybli&#380;enie \( \u\in V \):</p>

$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\end{equation*}
$$

<p>(\( \hbox{span} \) czyt. przestrze&#324; rozpi&#281;ta na wektorach...)</p>

<p>Maj&#261;c dany zbi&#243;r wektor&#243;w niezale&#380;nych liniowo 
\( \psib_0,\ldots,\psib_N \),
dowolny wektor \( \u\in V \) mo&#380;na zapisa&#263; jako:
</p>

$$ \u = \sum_{j=0}^Nc_j\psib_j$$


<div class="alert alert-block alert-notice alert-text-normal">
<b>Przyk&#322;ad - zadanie</b>
<p>
<p>Wykaza&#263;, &#380;e przy pomocy kombinacji liniowej
pewnych 3 wektor&#243;w przestrzeni 3D mo&#380;na skonstruowa&#263; dowolny wektor tej przestrzeni.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-najmniejszych-kwadrat&#243;w">Metoda najmniejszych kwadrat&#243;w </h2>

<p>Idea: znale&#378;&#263; takie \( c_0,\ldots,c_N \), aby \( E= ||\e||^2 \) by&#322; minimalizowany, \( \e=\f-\u \).</p>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)
\end{align*}
$$


$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\end{equation*}
$$

<p>Po odrobinie oblicze&#324; otrzymuje si&#281; <em>uk&#322;ad r&#243;wna&#324; liniowych</em>:</p>
$$
\begin{align}
\sum_{j=0}^N A_{i,j}c_j &= b_i,\quad i=0,\ldots,N
\label{_auto1}\\ 
A_{i,j} &= (\psib_i,\psib_j)
\label{_auto2}\\ 
b_i &= (\psib_i, \f)
\label{_auto3}
\end{align}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-galerkina">Metoda Galerkina </h2>

<p>Mo&#380;na pokaza&#263;, &#380;e poszukiwanie minimalnego \( ||\e|| \)
jest r&#243;wnowa&#380;ne poszukiwaniu \( \e \) ortogonalnego do wszystkich \( \v\in V \):
</p>

$$
(\e,\v)=0,\quad \forall\v\in V
$$

<p>co jest r&#243;wnowa&#380;ne temu aby \( \e \) by&#322; ortogonalny do ka&#380;dego wektora bazowego:</p>

$$ (\e,\psib_i)=0,\quad i=0,\ldots,N $$

<p>Warunek ortogonalno&#347;ci &ndash; podstawa metody Galerkina.
Generuje ten sam uk&#322;ad r&#243;wna&#324; liniowych co \( \LSM \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="fem:approx:global">Aproksymacja funkcji w przestrzeni funkcyjnej</h1>

<p>Niech \( V \) b&#281;dzie <em>przestrzeni&#261; funkcyjn&#261;</em> rozpi&#281;t&#261; na zbiorze <em>funkcji bazowych</em>
\( \baspsi_0,\ldots,\baspsi_N \),
</p>

$$
\begin{equation*}
V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\}
\end{equation*}
$$

<p>Dowoln&#261; funkcj&#281; tej przestrzeni \( u\in V \) mo&#380;na przedstawi&#263; jako kombinacj&#281;
liniow&#261; funkcji bazowych:
</p>

$$ u = \sum_{j\in\If} c_j\baspsi_j,\quad\If = \{0,1,\ldots,N\} $$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:LS">Uog&#243;lnienie \( \LSM \) na przestrzenie funkcyjne</h2>

<p>Tak jak dla przestrzeni wektorowych, minimalizujemy norm&#281; b&#322;&#281;du \( E \),
ze wzgl&#281;du na wsp&#243;&#322;czynniki \( c_j \), \( j\in\If \):
</p>

$$
E = (e,e) = (f-u,f-u) = \left(f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x)\right)
$$


$$ \frac{\partial E}{\partial c_i} = 0,\quad i=\in\If $$

<p>Czym jest iloczyn skalarny je&#347;li \( \baspsi_i \) jest funkcj&#261;?</p>

$$(f,g) = \int_\Omega f(x)g(x)\, dx$$

<p>(iloczyn skalarny funkcji cg jako uog&#243;lnienie il. skalarnego funkcji dyskretnych \( (\u, \v) = \sum_j u_jv_j \))</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="szczeg&#243;&#322;y-lsm">Szczeg&#243;&#322;y \( \LSM \) </h2>

$$
\begin{align*}
E(c_0,\ldots,c_N) &= (e,e) = (f-u,f-u) \\ 
 &= (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)
\end{align*}
$$


$$ \frac{\partial E}{\partial c_i} = 0,\quad i=\in\If $$

<p>Obliczenia identyczne jak dla przypadku wektorowego
->
w rezultacie otrzymujemy uk&#322;ad r&#243;wna&#324; liniowych
</p>

$$
\sum_{j\in\If}^N A_{i,j}c_j = b_i,\ i\in\If,\quad
A_{i,j} = (\baspsi_i,\baspsi_j),\ 
b_i = (f,\baspsi_i)
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-galerkina">Metoda Galerkina </h2>

<p>Jak poprzednio minimalizacja \( (e,e) \) jest r&#243;wnowa&#380;na</p>

$$
(e,\baspsi_i)=0,\quad i\in\If
\label{fem:approx:Galerkin0}
$$

<p>co z kolei jest r&#243;wnowa&#380;ne</p>

$$
(e,v)=0,\quad\forall v\in V
\label{fem:approx:Galerkin}
$$

<p>R&#243;wnowa&#380;no&#347;&#263; wzor&#243;w jak dla przestrzeni wektorowych.</p>

<p>R&#243;wnowa&#380;no&#347;&#263; wzor&#243;w jak dla wyprowadzenia przy pomocy \( \LSM \).</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:linear">Przyk&#322;ad: aproksymacja paraboli funkcj&#261; liniow&#261;</h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Problem</b>
<p>
<p>Dla zadanej funkcji \( f(x) = 10(x-1)^2 - 1 \) znale&#378;&#263; jej przybli&#380;enie
funkcj&#261; liniow&#261;.
</p>
</div>


$$
\begin{equation*} V = \hbox{span}\,\{1, x\}  \end{equation*}
$$

<p>czyli \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \) oraz \( N=1 \).
Szukane
</p>

$$
\begin{equation*}
u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x
\end{equation*}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-aproksymacja-paraboli-funkcj&#261;-liniow&#261;">Przyk&#322;ad: aproksymacja paraboli funkcj&#261; liniow&#261; </h2>

$$
\begin{align*}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, dx = 1\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, dx = 3/2\\ 
A_{1,0} &= A_{0,1} = 3/2\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,dx = 7/3\\ 
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3
\end{align*}
$$

<p>Rozwi&#261;zanie uk&#322;adu r&#243;wna&#324; 2x2:</p>

$$ c_0 = -38/3,\quad c_1 = 10,\quad u(x) = 10x - \frac{38}{3} $$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-aproksymacja-paraboli-funkcj&#261;-liniow&#261;">Przyk&#322;ad: aproksymacja paraboli funkcj&#261; liniow&#261; </h2>

$$
\begin{align*}
\left[
\begin{array}{cc}
     1      & \frac{3}{2} \\ 
\frac{3}{2} & \frac{7}{3} \\ 
\end{array}
\right]
\left[
\begin{array}{c}
c_0 \\ 
c_1 \\ 
\end{array}
\right]
=
\left[
\begin{array}{c}
\frac{7}{3} \\ 
\frac{13}{3} \\ 
\end{array}
\right]
\quad
\rightarrow
\quad
\left[
\begin{array}{c}
c_0 \\ 
c_1 \\ 
\end{array}
\right]
=
\left[
\begin{array}{c}
-38/3 \\ 
10 \\ 
\end{array}
\right]
\end{align*}
$$

$$ u(x) = 10x - 12 \frac{2}{3} $$


<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 8</p>
</center>
<p><img src="../fig/parabola_ls_linear.png" width="550" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:LS:code">Symboliczna realizacja algorytmu \( \LSM \)</h2>

<p>Problem: napisa&#263; program/funkcj&#281;, kt&#243;ry przeprowadzi obliczenia (obliczenie ca&#322;ek
i rozwi&#261;zanie uk&#322;adu r&#243;wna&#324; liniowych) i zwr&#243;ci
rozwi&#261;zanie postaci n \( u(x)=\sum_jc_j\baspsi_j(x) \).
</p>

<p>Niech </p>
<ul>
 <p><li> \( f(x) \) b&#281;dzie dane przez funkcj&#281; <code>sympy</code> oznaczon&#261; symbolem <code>f</code> (funkcj&#281; zmiennej (symbolu) <code>x</code>)</li>
 <p><li> <code>psi</code> b&#281;dzie list&#261; funkcji \( \sequencei{\baspsi} \),</li>
 <p><li> <code>Omega</code> b&#281;dzie dwuelementow&#261; krotk&#261;/list&#261; zawieraj&#261;c&#261; pocz&#261;tek i koniec przedzia&#322;u \( \Omega \)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="lsm-symbolicznie-podej&#347;cie-nr-1">\( \LSM \) symbolicznie:  podej&#347;cie nr 1 </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, psi, Omega):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">*</span>psi[j],
                                  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
            A[j,i] <span style="color: #666666">=</span> A[i,j]
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">*</span>f, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)):
        u <span style="color: #666666">+=</span> c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>psi[i]
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Spostrze&#380;enie: macierz uk&#322;adu jest symetryczna, dzi&#281;ki czemu mo&#380;na zoptymalizowa&#263; proces wyznaczania jej element&#243;w</p>

<ul>
 <p><li> Mo&#380;e si&#281; zda&#380;y&#263;, &#380;e obliczanie ca&#322;ki si&#281; nie powiedzie (skomplikowana funkcja <code>f</code>) , <code>sym.integrate</code> zwr&#243;ci wtedy obiekt typu <code>sym.Integral</code>. Ulepszenie kodu: sprawdzenie czy takie zdarzenie wyst&#261;pi&#322;o i ew. obliczenia numeryczne.</li>
 <p><li> Ulepszenie 2: Dodatkowa flaga przy pomocy, kt&#243;rej u&#380;ytkownik mo&#380;e zdecydowa&#263; bezpo&#347;rednio jaki rodzaj ca&#322;kowania (symboliczny czy numeryczny) ma zosta&#263; wykorzystany.</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="lsm-symbolicznie-podej&#347;cie-nr-2">\( \LSM \) symbolicznie:  podej&#347;cie nr 2 </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
    <span style="color: #666666">...</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>psi[j]
            <span style="color: #008000; font-weight: bold">if</span> symbolic:
                I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
                <span style="color: #408080; font-style: italic"># Could not integrate symbolically,</span>
                <span style="color: #408080; font-style: italic"># fall back on numerical integration</span>
                integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
                I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
            A[i,j] <span style="color: #666666">=</span> A[j,i] <span style="color: #666666">=</span> I

        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>f
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    <span style="color: #666666">...</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="prezentacja-rozwi&#261;zania">Prezentacja rozwi&#261;zania </h2>

<p>Graficzne por&#243;wnanie \( f \) i \( u \):</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">comparison_plot</span>(f, u, Omega, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp.pdf&#39;</span>):
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #408080; font-style: italic"># Turn f and u to ordinary Python functions</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&quot;numpy&quot;</span>)
    u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], u, modules<span style="color: #666666">=</span><span style="color: #BA2121">&quot;numpy&quot;</span>)
    resolution <span style="color: #666666">=</span> <span style="color: #666666">401</span>  <span style="color: #408080; font-style: italic"># no of points in plot</span>
    xcoor  <span style="color: #666666">=</span> linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], resolution)
    exact  <span style="color: #666666">=</span> f(xcoor)
    approx <span style="color: #666666">=</span> u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #BA2121">&#39;approximation&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>])
    savefig(filename)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="zastosowanie-kodu">Zastosowanie kodu </h2>
<!-- ===== Application of the software: fit a parabola by a straight line ===== -->


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2-1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> u, c <span style="color: #666666">=</span> least_squares(f<span style="color: #666666">=</span>f, psi<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, x], Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> comparison_plot(f, u, Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 9</p>
</center>
<p><img src="../fig/parabola_ls_linear.png" width="600" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:exact">Przypadek aproksymacji funkcji \( f\in V \)</h2>

<ul>
 <p><li> Rozszerzmy zbi&#243;r funkcji bazowych przestrzeni \( V \) o funkcj&#281; \( \baspsi_2=x^2 \), wci&#261;&#380; poszukuj&#261;c przybli&#380;enia dla funkcji \( f=10(x-1)^2-1 \) w przestrzeni \( V \)</li>
 <p><li> -> przybli&#380;enie paraboli pewn&#261; parabol&#261; \ldots</li>
 <p><li> Rozwi&#261;zanie odwzoruje \( f \) &#347;ci&#347;le!</li> 
</ul>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2-1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> u, c <span style="color: #666666">=</span> least_squares(f<span style="color: #666666">=</span>f, psi<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, x, x<span style="color: #666666">**2</span>], Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">print</span> u
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">print</span> sym<span style="color: #666666">.</span>expand(f)
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Rozwi&#261;zanie przybli&#380;one \( \equiv \) rozwi&#261;zanie dok&#322;adne, je&#347;li \( f \in V \)!</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="uog&#243;lnienie-przypadek-aproksymacji-funkcji-f-in-v">Uog&#243;lnienie: Przypadek aproksymacji funkcji \( f\in V \) </h2>

<ul>
 <p><li> A co je&#347;li baza to \( \psi_i(x)=x^i \) dla \( i=0,\ldots,N=40 \)?</li>
 <p><li> Wynik funkcji <code>least_squares</code>: dla \( i>2 \), \( c_i=0 \)</li>
</ul>
<div class="alert alert-block alert-block alert-text-normal">
<b>Wniosek og&#243;lny:</b>
<p>
<p>Je&#347;li \( f\in V \), \( \LSM \) oraz metoda Galerkina zwr&#243;c&#261; \( u=f \).</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="dlaczego-dla-f-in-v-aproksymacja-jest-bezb&#322;&#281;dna-dow&#243;d">Dlaczego dla \( f\in V \) aproksymacja jest bezb&#322;&#281;dna? Dow&#243;d: </h2>

<p>Je&#347;li \( f\in V \),
wtedy \( f=\sum_{j\in\If}d_j\baspsi_j \), dla pewnego \( \sequencei{d} \).
Wtedy
</p>

$$
\begin{equation*}
b_i = (f,\baspsi_i) = \sum_{j\in\If}d_j(\baspsi_j, \baspsi_i)
= \sum_{j\in\If} d_jA_{i,j}
\end{equation*}
$$

<p>a URL \( \sum_j A_{i,j}c_j = b_i \), \( i\in\If \), przedstawia sie:</p>

$$
\begin{equation*}
\sum_{j\in\If}c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},\quad i\in\If
\end{equation*}
$$

<p>co oznacza, &#380;e \( c_i=d_i \) dla \( i\in\If \), czyli \( u \) jest to&#380;same z \( f \).</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:illconditioning">Sko&#324;czona precyzja oblicze&#324; numerycznych</h2>

<p>Poprzednie wnioski -> teoria i obliczenia symboliczne \ldots</p>

<p>Co w przypadku oblicze&#324; numerycznych? -> (rozwi&#261;zanie URL macierzami
liczb zmiennoprzecinkowych)
</p>

<p>\( f \) to wci&#261;&#380; funkcja kwadratowa przybli&#380;ana przez</p>

$$ u(x) = c_0 + c_1x + c_2x^2 + c_3x^3 +\cdots + c_Nx^N $$

<p>Oczekiwane: \( c_2=c_3=\cdots=c_N=0 \), skoro \( f\in V \) oznacza \( u=f \).</p>

<p>A naprawd&#281;?</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="sko&#324;czona-prezycja-oblicze&#324;-numerycznych-ndash-wyniki">Sko&#324;czona prezycja oblicze&#324; numerycznych &ndash; wyniki </h2>

<table class="dotable" border="1">
<thead>
<tr><th align="center">teoria</th> <td align="center"><code>sympy</code></td> <td align="center"><code>numpy32</code></td> <td align="center"><code>numpy64</code></td> </tr>
</thead>
<tbody>
<tr><td align="right">   9         </td> <td align="right">   9.62                  </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20       </td> <td align="right">   -23.39                </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10        </td> <td align="right">   17.74                 </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   -9.19                 </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   5.25                  </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   0.18                  </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   -2.48                 </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   1.81                  </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   -0.66                 </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   0.12                  </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0         </td> <td align="right">   -0.001                </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</tbody>
</table>

<ul>
  <p><li> Kolumna 2: <code>matrix</code> oraz <code>lu_solve</code> z biblioteki <code>sympy.mpmath.fp</code></li>
  <p><li> Kolumna 3: <code>numpy</code> 4B liczby zmiennoprzecinkowe</li>
  <p><li> Kolumna 4: <code>numpy</code> 8B liczby zmiennoprzecinkowe</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="z&#322;e-uwarunkowanie-url-liniowa-zale&#380;no&#347;&#263;-w-bazie">Z&#322;e uwarunkowanie URL - ''liniowa zale&#380;no&#347;&#263;'' w bazie </h2>

<ul>
 <p><li> Znaczne b&#322;&#281;dy zaokr&#261;gle&#324; rozwi&#261;zania numerycznego (!)</li>
 <p><li> Jednocze&#347;nie ''na oko'' (graficzne) rozwi&#261;zanie wygl&#261;da w porz&#261;dku (!)</li>
</ul>
<p>&#377;r&#243;d&#322;o k&#322;opot&#243;w: funkcje \( x^i \) dla bardzo du&#380;ych \( i \) staj&#261; si&#281; praktycznie
liniowo zale&#380;ne 
</p>

<!-- !bslidecell 00 -->
<p>4 rozwi&#261;zania zadania przybli&#380;enia paraboli</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 10</p>
</center>
<p><img src="../figMB/comparison_parabola_err.png" width="500" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !bslidecell 01 -->
<p>Wykresy funkcji \( x^i \) dla \( i=0 \ldots 14 \)</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 11</p>
</center>
<p><img src="../fig/ill_conditioning.png" width="500" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="z&#322;e-uwarunkowanie-url-wnioski">Z&#322;e uwarunkowanie URL: wnioski </h2>

<ul>
 <p><li> Prawie liniowa zale&#380;no&#347;&#263; funkcji bazowych skutkuje bliskoosobliwymi macierzami</li>
 <p><li> macierz prawie osobliwa \( \equiv \) <em>macierz &#378;le uwarunkowana</em> -> problemy w trakcie m.elim. Gaussa</li>
 <p><li> Baza wielomian&#243;w \( 1, x, x^2, x^3, x^4, \ldots \) to ''nienajszcz&#281;&#347;liwszy'' wyb&#243;r</li>
 <p><li> Istniej&#261; lepsze bazy (nawet wielomianowe), ale im bardziej ortogonalne te bazy s&#261;, tym lepiej (\( (\baspsi_i,\baspsi_j)\approx 0 \))</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:Fourier">Aproksymacja szeregami Fouriera; problem and code</h2>

<p>Aproksymacja funkcji \( f \) szeregiem Fouriera</p>

$$ u(x) = \sum_i a_i\sin i\pi x = \sum_{j=0}^Nc_j\sin((j+1)\pi x) $$

<p>to tylko ''zmiana bazy'':</p>

$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\end{equation*}
$$

<p>Obliczenia z wykorzystaniem funkcji <code>least_squares</code>:</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">N <span style="color: #666666">=</span> <span style="color: #666666">3</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> sin, pi
psi <span style="color: #666666">=</span> [sin(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">1</span>
Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]
u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega)
comparison_plot(f, u, Omega)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="aproksymacja-szeregami-fouriera-wykres">Aproksymacja szeregami Fouriera; wykres </h2>

<p>L: \( N=3 \), P: \( N=11 \):</p>
<br />

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 12</p>
</center>
<p><img src="../fig/parabola_ls_sines4_12.png" width="900" align="bottom"></p>
</center>

<div class="alert alert-block alert-block alert-text-normal">
<b>Problem:</b>
<p>
<p>Dla ka&#380;dej f.bazowej jest \( \baspsi_i(0)=0 \) przez co \( u(0)=0 \neq f(0)=9 \).
Podobna sytuacja dla \( x=1 \).
Warto&#347;ci \( u \) na brzegach b&#281;d&#261; zawsze niepoprawne!
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="aproksymacja-szeregami-fouriera-ulepszenie">Aproksymacja szeregami Fouriera; ulepszenie </h2>

<ul>
 <p><li> Znaczna poprawa aproksymacja dla \( N=11 \) wyraz&#243;w, pomimo niepo&#380;&#261;danych rozbie&#380;no&#347;ci w \( x=0 \) i \( x=1 \)</li>
 <p><li> Mo&#380;liwe rozwi&#261;zanie: doda&#263; sk&#322;adow&#261;, kt&#243;ra pozwoli na odwzorowanie w&#322;a&#347;ciwych warto&#347;ci na brzegu</li>
</ul>
$$ u(x) = {\color{red}f(0)(1-x) + xf(1)} + \sum_{j\in\If} c_j\baspsi_j(x) $$

<p>Dodatkowy wyraz nie tylko zapewnia \( u(0)=f(0) \) oraz \( u(1)=f(1) \),
ale tak&#380;e zaskakuj&#261;co dobrze poprawia jako&#347;&#263; aproksymacji!
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="aproksymacja-szeregami-fouriera-wyniki">Aproksymacja szeregami Fouriera; wyniki  </h2>

<p>\( N=3 \) vs \( N=11 \):</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 13</p>
</center>
<p><img src="../fig/parabola_ls_sines4_12_wfterm.png" width="900" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="bazy-funkcji-ortogonalnych">Bazy funkcji ortogonalnych </h2>

<p>Zalety wyboru funkcji sinus jako funkcji bazowych:</p>

<ul>
 <p><li> funkcje bazowe s&#261; parami ortogonalne: \( (\baspsi_i,\baspsi_j)=0 \) (jedynie  \( (\baspsi_i,\baspsi_j) \neq 0 \))) dzi&#281;ki czemu</li>
 <p><li> macierz \( A_{i,j} \) jest diagonalna, dzi&#281;ki czemu</li>
 <p><li> nie ma potrzeby rozwi&#261;zywa&#263; URL! Rozwi&#261;zanie sprowadza si&#281; do obliczenia: \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)</li> 
 <p><li> wynik: rozwini&#281;cie funkcji \( f \) w szereg Fouriera</li>
</ul>
<p><em>W og&#243;lnym przypadku</em>, dla baz ortogonalnych,
\( A_{i,j} \) jest macierz&#261; diagonaln&#261;, a nieznane wsp&#243;&#322;czynniki \( c_i \)
mo&#380;na &#322;atwo obliczy&#263;:
</p>

$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\baspsi_i)}{(\baspsi_i,\baspsi_i)}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="implementacja-lsm-dla-ortogonalnych-funkcji-bazowych">Implementacja \( \LSM \) dla ortogonalnych funkcji bazowych </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares_orth</span>(f, psi, Omega):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>(N<span style="color: #666666">+1</span>)
    b <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>(N<span style="color: #666666">+1</span>)
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        A[i] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">**2</span>, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
        b[i] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">*</span>f,  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
    c <span style="color: #666666">=</span> [b[i]<span style="color: #666666">/</span>A[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(b))]
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)):
        u <span style="color: #666666">+=</span> c[i]<span style="color: #666666">*</span>psi[i]
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="implementacja-lsm-dla-ortogonalnych-funkcji-bazowych-ca&#322;kowanie-symboliczne-i-numeryczne">Implementacja \( \LSM \) dla ortogonalnych funkcji bazowych: ca&#322;kowanie symboliczne i numeryczne </h2>

<ul>
 <p><li> Uwzgl&#281;dnienie parametru steruj&#261;cego wyborem rodzaju ca&#322;kowania (argument <code>symbolic</code>).</li>
 <p><li> W przypadku gdy ca&#322;kowanie symboliczne zawiedzie (<code>sym.integrate</code> zwraca <code>sym.Integral</code>), obliczenia wykonywane numerycznie (w przypadku funkcji sinus nie powinno by&#263; problem&#243;w z symbolicznym obliczeniem \( \int_\Omega\basphi_i^2dx \))</li>
</ul>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares_orth</span>(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
    <span style="color: #666666">...</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #408080; font-style: italic"># Diagonal matrix term</span>
        A[i] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">**2</span>, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))

        <span style="color: #408080; font-style: italic"># Right-hand side term</span>
        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>f
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand,  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            <span style="color: #008000">print</span> <span style="color: #BA2121">&#39;numerical integration of&#39;</span>, integrand
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
        b[i] <span style="color: #666666">=</span> I
    <span style="color: #666666">...</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:interp">Metoda kolokacji (interpolacji); idea i teoria</h2>

<p>Inny spos&#243;b znalezienia przybli&#380;enia \( f(x) \) przez \( u(x)=\sum_jc_j\baspsi_j \):</p>

<ul>
 <p><li> Wymuszamy \( u(\xno{i}) = f(\xno{i}) \) w pewnych wybranych punktach  \( \sequencei{x} \) (punktach <em>kolokacji</em>)</li>
 <p><li> \( u \) <em>interpoluje</em> \( f \)</li>
 <p><li> metoda znana jako metoda <em>kolokacji</em> (<em>interpolacji</em>)</li>
</ul>
$$ u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i})
\quad i\in\If,N
$$

<p>Wsp&#243;&#322;czynniki wygenerowanego uk&#322;adu r&#243;wna&#324; to po prostu warto&#347;ci funkcji,
nie ma potrzeby ca&#322;kowania!
</p>

$$
\begin{align}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If
\label{_auto4}\\ 
A_{i,j} &= \baspsi_j(\xno{i})
\label{_auto5}\\ 
b_i &= f(\xno{i})
\label{_auto6}
\end{align}
$$

<p>W og&#243;lnym przypadku macierz wynikowa niesymetryczna: \( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) </p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-kolokacji-ndash-implementacja">Metoda kolokacji &ndash; implementacja </h2>

<p>Zmienna <code>points</code> przechowuje punkty kolokacji</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">interpolation</span>(f, psi, points):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #408080; font-style: italic"># Turn psi and f into Python functions</span>
    psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>lambdify([x], psi[i]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> psi[j](points[i])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> f(points[i])
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)):
        u <span style="color: #666666">+=</span> c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>psi[i](x)
    <span style="color: #008000; font-weight: bold">return</span> u
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-kolokacji-przybli&#380;enie-paraboli-funkcj&#261;-liniow&#261;">Metoda kolokacji: przybli&#380;enie paraboli funkcj&#261; liniow&#261; </h2>

<ul>
 <p><li> Problem: jak wybra&#263; \( \xno{i} \)?</li>
 <p><li> Wynik zale&#380;y od po&#322;o&#380;enia punkt&#243;w kolokacji!</li>
</ul>
<p>\( (4/3,5/3) \) vs \( (1,2) \):</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 14</p>
</center>
<p><img src="../fig/parabola_inter.png" width="700" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:regression">Regresja</h2>

<ul>
 <p><li> Idea: metoda kolokacji dla \( m \gg N+1 \) punkt&#243;w</li>
 <p><li> Problem: Wi&#281;cej r&#243;wna&#324; ni&#380; niewiadomych</li>
 <p><li> Znana np. ze statystyki <em>regresja</em></li>
</ul>
<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 15</p>
</center>
<p><img src="../fig/parabola_by_regression.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="regresja-ndash-nadokre&#347;lone-url">Regresja &ndash; nadokre&#347;lone URL </h2>

$$
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i}),
\quad i=0,1,\ldots,m
$$


$$ \sum_{j\in\If} A_{i,j}c_j = b_i,\quad i=0,1,\ldots,m $$


$$ A_{i,j} = \baspsi_j(\xno{i}),\quad
b_i = f(\xno{i})$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="rozwi&#261;zywanie-nadokre&#347;lonych-url-przy-pomocy-lsm">Rozwi&#261;zywanie nadokre&#347;lonych URL przy pomocy \( \LSM \) </h2>

<ul>
 <p><li> Jak rozwi&#261;za&#263; \( Ac=b \) je&#347;li jest wi&#281;cej r&#243;wna&#324; ni&#380; niewiadomych?</li>
 <p><li> Idea: Poszukiwanie rozwi&#261;zania minimalizuj&#261;cego \( r=b-Ac \)</li>
 <p><li> Rezultat: uk&#322;ad r&#243;wna&#324; normalnych \( A^TAc=A^Tb \)</li>
 <p><li> Zapiszmy uk&#322;ad w postaci \( Bc=d \)</li>
 <p><li> \( B = A^TA \) ju&#380; kwadratowe: uk&#322;ad r&#243;wna&#324; o rozmiarach \( (N+1)\times(N+1) \)</li> 
</ul>
$$
\begin{align*}
B_{i,j} &= \sum_k A^T{i,k}A_{k,j} = \sum_k A{k,i}A_{k,j}
=\sum_{k=0}^m\baspsi_i(\xno{k}) \baspsi_j(\xno{k})
\\ 
d_i &=\sum_k A^T_{i,k}b_k = \sum_k A_{k,i}b_k =\sum_{k=0}^m
\baspsi_i(\xno{k})f(\xno{k})
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="implementacja">Implementacja </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">regression</span>(f, psi, points):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(points)
    <span style="color: #408080; font-style: italic"># Use numpy arrays and numerical computing</span>
    B <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    d <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    <span style="color: #408080; font-style: italic"># Wrap psi and f in Python functions rather than expressions</span>
    <span style="color: #408080; font-style: italic"># so that we can evaluate psi at points[i]</span>
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    psi_sym <span style="color: #666666">=</span> psi  <span style="color: #408080; font-style: italic"># save symbolic expression</span>
    psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>lambdify([x], psi[i]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
            B[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m<span style="color: #666666">+1</span>):
                B[i,j] <span style="color: #666666">+=</span> psi[i](points[k])<span style="color: #666666">*</span>psi[j](points[k])
        d[i] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m<span style="color: #666666">+1</span>):
            d[i] <span style="color: #666666">+=</span> psi[i](points[k])<span style="color: #666666">*</span>f(points[k])
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(B, d)
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi_sym[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>))
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-zastosowania-ndash-kod">Przyk&#322;ad zastosowania &ndash; kod </h2>

<ul>
 <p><li> Zadanie: Dokona&#263; aproksymacji funkcji \( f(x)=10(x-1)^2-1 \) na przedziale \( \Omega=[1,2] \) przy pomocy funkcji liniowej.</li> 
</ul>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">1</span>
psi <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, x]
Omega <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]
m_values <span style="color: #666666">=</span> [<span style="color: #666666">2-1</span>, <span style="color: #666666">8-1</span>, <span style="color: #666666">64-1</span>]
<span style="color: #408080; font-style: italic"># Create m+3 points and use the inner m+1 points</span>
<span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> m_values:
    points <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], m<span style="color: #666666">+3</span>)[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
    u, c <span style="color: #666666">=</span> regression(f, psi, points)
    comparison_plot(f, u, Omega, points<span style="color: #666666">=</span>points,
        points_legend<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> interpolation points&#39;</span> <span style="color: #666666">%</span> (m<span style="color: #666666">+1</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-zastosowania-ndash-wyniki">Przyk&#322;ad zastosowania &ndash; wyniki </h2>

$$
\begin{align*}
u(x) &= 10x - 13.2,\quad 2\hbox{ punkty}\\ 
u(x) &= 10x - 12.7,\quad 8\hbox{ punktów}\\ 
u(x) &= 10x - 12.7,\quad 64\hbox{ punkty}
\end{align*}
$$


<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 16</p>
</center>
<p><img src="../fig/parabola_by_regression.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:global:Lagrange">Wielomiany Lagrange'a</h2>

<p>Motywacja::</p>

<ul>
 <p><li> Metoda kolokacji pozwala unikn&#261;&#263; ca&#322;kowania</li>
 <p><li> Dla macierzy diagonalnej \( A_{i,j} = \baspsi_j(\xno{i}) \) rozwi&#261;zanie URL jest banalnie proste</li>
</ul>
<p>W&#322;asno&#347;&#263; <em>wielomian&#243;w Lagrange'a</em> \( \baspsi_j \):</p>

$$ \baspsi_i(\xno{j}) =\delta_{ij},\quad \delta_{ij} =
\left\lbrace\begin{array}{ll}
1, & i=j\\ 
0, & i\neq j
\end{array}\right.
$$

<p>Zatem, \( c_i = f(x_i) \) and</p>

$$
u(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)
$$


<ul>
 <p><li> Wielomiany Lagrange'a w po&#322;&#261;czeniu z metod&#261; kolokacji s&#261; niezwykle wygodne</li>
 <p><li> Cz&#281;sto stosowane w \( \FEM \)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wielomiany-lagrange-a-ndash-wz&#243;r-i-implementacja">Wielomiany Lagrange'a &ndash; wz&#243;r i implementacja </h2>

$$
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N}
$$



<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lagrange_polynomial</span>(x, i, points):
    p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(points)):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #666666">!=</span> i:
            p <span style="color: #666666">*=</span> (x <span style="color: #666666">-</span> points[k])<span style="color: #666666">/</span>(points[i] <span style="color: #666666">-</span> points[k])
    <span style="color: #008000; font-weight: bold">return</span> p
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wielomiany-lagrange-a-ndash-zach&#281;caj&#261;cy-przyk&#322;ad-zastosowania">Wielomiany Lagrange'a &ndash; zach&#281;caj&#261;cy przyk&#322;ad zastosowania </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 17</p>
</center>
<p><img src="../fig/Lagrange_ls_interp_sin_4.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wielomiany-lagrange-a-ndash-mniej-zach&#281;caj&#261;cy-przyk&#322;ad-zastosowania">Wielomiany Lagrange'a &ndash; mniej zach&#281;caj&#261;cy przyk&#322;ad zastosowania </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 18</p>
</center>
<p><img src="../fig/Lagrange_interp_abs_8_15.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wielomiany-lagrange-a-ndash-efekt-runge-go">Wielomiany Lagrange'a &ndash; efekt Runge'go </h2>

<p>12 punkt&#243;w, dwa wielomiany stopnia 11
(Uwaga!: \( \psi_2(x_2) \neq 0 \) i  \( \psi_7(x_7) \neq 0 \)
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 19</p>
</center>
<p><img src="../fig/Lagrange_basis_12.png" width="500" align="bottom"></p>
</center>

<p>Problem: oscylacje w okolicach kra&#324;c&#243;w przedzia&#322;&#243;w dla wi&#281;kszych \( N \).</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wielomiany-lagrange-a-jak-zapobiec-oscylacjom">Wielomiany Lagrange'a: jak zapobiec oscylacjom? </h2>

<p>Odpowiedni dob&#243;r w&#281;z&#322;&#243;w interpolacji &ndash; <em>w&#281;z&#322;y Czebyszewa</em>:</p>

$$
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}\pi\right),\quad i=0\ldots,N
$$

<p>na przedziale \( [a,b] \).</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wielomiany-lagrange-a-w&#281;z&#322;y-czebyszewa">Wielomiany Lagrange'a + w&#281;z&#322;y Czebyszewa </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 20</p>
</center>
<p><img src="../fig/Lagrange_interp_abs_Cheb_8_15.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wielomiany-lagrange-a-w&#281;z&#322;y-czebyszewa">Wielomiany Lagrange'a + w&#281;z&#322;y Czebyszewa </h2>

<p>12 punkt&#243;w, dwa wielomiany stopnia 11.</p>

<p>Uwaga!: Tym razem w&#281;z&#322;y s&#261; inaczej rozmieszczone!</p>

<p>Mniej oscylacyjny charakter wielomian&#243;w w por&#243;wnaniu do w&#281;z&#322;&#243;w
r&#243;wnomiernie rozmieszczonych.
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 21</p>
</center>
<p><img src="../fig/Lagrange_basis_Cheb_12.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="fem:approx:fe">Funkcje bazowe element&#243;w sko&#324;czonych</h1>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 22</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_2_3.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="funkcje-bazowe-o-no&#347;niku-nieograniczonym-baspsi-i-x-neq-0-prawie-w-ca&#322;ym-przedziale-okre&#347;lono&#347;ci">Funkcje bazowe o no&#347;niku nieograniczonym: \( \baspsi_i(x) \neq 0 \) prawie w ca&#322;ym przedziale okre&#347;lono&#347;ci </h2>

<p>No&#347;nik funkcji: domkni&#281;cie zbioru argument&#243;w funkcji, dla kt&#243;rych ma ona warto&#347;&#263; r&#243;&#380;n&#261; od zera (takie iksy dla kt&#243;rych \( f(x) \neq 0 \))</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 23</p>
</center>
<p><img src="../fig/u_example_sin.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="funkcje-bazowe-o-no&#347;niku-ograniczonym-ndash-fem">Funkcje bazowe o no&#347;niku ograniczonym &ndash; \( \FEM \) </h2>

<ul>
 <p><li> <em>No&#347;nik zwarty</em> (<em>Local support</em>): domkni&#281;cie zbioru tych \( x \)-&#243;w, dla kt&#243;rych \( \baspsi_i(x) \neq 0 \)</li>
 <p><li> Typowe dla 1D - funkcje tr&#243;jk&#261;tne (hat-shaped)</li>
 <p><li> \( u(x) \) zbudowana przy pomocy takich funkcji \( \baspsi_i \) b&#281;dzie funkcj&#261; przedzia&#322;ami liniow&#261;</li> 
 <p><li> Niech symbol \( \basphi_i \) oznacza odt&#261;d tego typu funkcj&#281; tr&#243;jk&#261;tn&#261; (przyjmijmy r&#243;wnie&#380; \( \baspsi_i=\basphi_i \))</li>
</ul>
<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 24</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_2_3.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kombinacja-liniowa-funkcji-tr&#243;jk&#261;tnych">Kombinacja liniowa funkcji tr&#243;jk&#261;tnych </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 25</p>
</center>
<p><img src="../fig/u_example_fe2.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:fe:def:elements:nodes">Elementy i w&#281;z&#322;y</h2>

<p>Podzielmy \( \Omega \) na \( N_e \) rozdzielnych podobszar&#243;w podobszar&#243;w &ndash; <em>element&#243;w</em>:</p>

$$
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(N_e)}
$$

<p>Na ka&#380;dym elemencie wprowadzamy \( N_n \) <em>wez&#322;&#243;w</em>
(punkt&#243;w): \( \xno{0},\ldots,\xno{N_n-1} \)
</p>

<ul>
 <p><li> \( \basphi_i(x) \) &ndash; \( i \)-ta funkcja bazowa</li> 
 <p><li> \( \basphi_i=1 \) w w&#281;&#378;le \( i \) i \( \basphi_i=0 \) w pozosta&#322;ych w&#281;z&#322;ach</li>
 <p><li> \( \basphi_i \) to wielomian Lagrange'a na ka&#380;dym elemencie</li>
 <p><li> Dla w&#281;z&#322;&#243;w granicznych, le&#380;&#261;cych w punktach &#322;&#261;cz&#261;cych dwa elementy funkcja \( \basphi_i \) jest zbudowane z wielomian&#243;w Lagrange'a na obu elementach</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-obszar-podzielony-na-elementy-dwuw&#281;z&#322;owe-elementy-typu-p1">Przyk&#322;ad: obszar podzielony na elementy dwuw&#281;z&#322;owe (elementy typu P1) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 26</p>
</center>
<p><img src="../fig/fe_mesh1D_P1.png" width="500" align="bottom"></p>
</center>

<p>Struktura <code>nodes</code> &ndash; wsp&#243;&#322;rz&#281;dne w&#281;z&#322;&#243;w.</p>

<p>Struktura <code>elements</code> &ndash;  numery (globalne) w&#281;z&#322;&#243;w tworz&#261;cych
odpowiedni element.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2.4</span>, <span style="color: #666666">3.6</span>, <span style="color: #666666">4.8</span>, <span style="color: #666666">5</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>]]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-dwie-funkcje-bazowe-na-siatce">Przyk&#322;ad: dwie funkcje bazowe na siatce </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 27</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_2_3.png" width="600" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-elementy-niejednorodne-o-trzech-w&#281;z&#322;ach-elementy-typu-p2">Przyk&#322;ad: elementy niejednorodne o trzech w&#281;z&#322;ach (elementy typu P2) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 28</p>
</center>
<p><img src="../fig/fe_mesh1D_P2.png" width="500" align="bottom"></p>
</center>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.125</span>, <span style="color: #666666">0.25</span>, <span style="color: #666666">0.375</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.625</span>, <span style="color: #666666">0.75</span>, <span style="color: #666666">0.875</span>, <span style="color: #666666">1.0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>], [<span style="color: #666666">6</span>, <span style="color: #666666">7</span>, <span style="color: #666666">8</span>]]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-funkcje-bazowe-na-siatce-elementy-typu-p2">Przyk&#322;ad: funkcje bazowe na siatce (elementy typu P2) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 29</p>
</center>
<p><img src="../fig/phi/mpl_fe_basis_p2_4e.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-elementy-typu-p3-o-czterech-w&#281;z&#322;ach-interpolacji">Przyk&#322;ad: elementy typu P3 (o czterech w&#281;z&#322;ach interpolacji) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 30</p>
</center>
<p><img src="../fig/fe_mesh1D_d4_stretched.png" width="500" align="bottom"></p>
</center>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">d <span style="color: #666666">=</span> <span style="color: #666666">3</span>  <span style="color: #408080; font-style: italic"># d+1 nodes per element</span>
num_elements <span style="color: #666666">=</span> <span style="color: #666666">4</span>
num_nodes <span style="color: #666666">=</span> num_elements<span style="color: #666666">*</span>d <span style="color: #666666">+</span> <span style="color: #666666">1</span>
nodes <span style="color: #666666">=</span> [i<span style="color: #666666">*0.5</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_nodes)]
elements <span style="color: #666666">=</span> [[i<span style="color: #666666">*</span>d<span style="color: #666666">+</span>j <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_elements)]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-funkcje-bazowe-na-siatce-elementy-typu-p3">Przyk&#322;ad: funkcje bazowe na siatce (elementy typu P3) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 31</p>
</center>
<p><img src="../fig/phi/mpl_fe_basis_p3_4e.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="indeksacja-nieregularna">Indeksacja nieregularna </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 32</p>
</center>
<p><img src="../fig/fe_mesh1D_random_numbering.png" width="500" align="bottom"></p>
</center>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">nodes <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">5.5</span>, <span style="color: #666666">4.2</span>, <span style="color: #666666">0.3</span>, <span style="color: #666666">2.2</span>, <span style="color: #666666">3.1</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">0</span>], [<span style="color: #666666">5</span>, <span style="color: #666666">2</span>]]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wsp&#243;&#322;czynniki-c-i-ndash-interpretacja">Wsp&#243;&#322;czynniki \( c_i \) &ndash; interpretacja </h2>

<p>Wa&#380;na w&#322;asno&#347;&#263;: \( c_i \)
to warto&#347;&#263; funkcji \( u \) w w&#281;&#378;le \( i \), \( \xno{i} \):
</p>

$$
u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
$$

<p>Pow&#243;d: \( \basphi_j(\xno{i}) =0 \) je&#347;li \( i\neq j \) i \( \basphi_i(\xno{i}) =1 \)</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="w&#322;asno&#347;ci-funkcji-bazowych">W&#322;asno&#347;ci funkcji bazowych </h2>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) jedynie na tych elementach, kt&#243;re zawieraj&#261; w&#281;ze&#322;
<ol type="a"></li>
  <p><li> globalnym indeksie \( i \)</li>
</ol>
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) wtedy i tylko wtedy gdy w&#281;zly \( i \) oraz \( j \) le&#380;&#261; na tym samym elemencie</li>
</ul>
<p>Poniewa&#380; \( A_{i,j}=\int\basphi_i\basphi_j\dx \),
<em>wi&#281;kszo&#347;&#263; wsp&#243;&#322;czynnik&#243;w macierzy b&#281;dzie r&#243;wna zero</em>
-> macierze rzadkie
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 33</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_i_im1.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="konstrukcja-kwadratowych-basphi-i-elementy-typu-p2">Konstrukcja kwadratowych \( \basphi_i \) (elementy typu P2) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 34</p>
</center>
<p><img src="../fig/phi/mpl_fe_basis_p2_4e.png" width="500" align="bottom"></p>
</center>

<ol>
<p><li> ka&#380;dy w&#281;ze&#322; elementu ma przypisany wielomian Lagrange'a</li>
<p><li> Wielomian o warto&#347;ci 1 na brzegu elementu nale&#380;y ''po&#322;&#261;czy&#263;'' z wielomianem z s&#261;siedniego elementu, kt&#243;ry ma warto&#347;&#263; 1 w tym samym punkcie</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="liniowe-basphi-i-elementy-typu-p1">Liniowe \( \basphi_i \) (elementy typu P1) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 35</p>
</center>
<p><img src="../fig/phi/mpl_fe_basis_p1_4e.png" width="500" align="bottom"></p>
</center>

$$
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1}\\ 
(x - \xno{i-1})/h
& \xno{i-1} \leq x < \xno{i}\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1}\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="sze&#347;cienne-basphi-i-elementy-typu-p3">Sze&#347;cienne \( \basphi_i \) (elementy typu P3) </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 36</p>
</center>
<p><img src="../fig/phi/mpl_fe_basis_p3_4e.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="fem:approx:global:linearsystem">Generowanie URL</h1>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 37</p>
</center>
<p><img src="../fig/sparsity_pattern_1D_30unif.png" width="600" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-1-obliczenie-warto&#347;ci-niediagonalnego-elementu-macierzy">Przyk&#322;ad 1: Obliczenie warto&#347;ci (niediagonalnego) elementu macierzy </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 38</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_2_3.png" width="300" align="bottom"></p>
</center>

<p>Uproszczenie: elementy jednakowej d&#322;ugo&#347;ci.</p>

<p>\( A_{2,3}=\int_\Omega\basphi_2\basphi_3 dx \): \( \basphi_2\basphi_3\neq 0 \)
jedynie na elemencie 2. Dla tego elementu:
</p>

$$ \basphi_3(x) = (x-x_2)/h,\quad \basphi_2(x) = 1- (x-x_2)/h$$


$$
A_{2,3} = \int_\Omega \basphi_2\basphi_{3}\dx =
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right) \frac{x - x_{2}}{h}
 \dx = \frac{h}{6}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-2-obliczenie-warto&#347;ci-diagonalnego-elementu-macierzy">Przyk&#322;ad 2: Obliczenie warto&#347;ci (diagonalnego) elementu macierzy </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 39</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_2_3.png" width="500" align="bottom"></p>
</center>

$$ A_{2,2} =
\int_{\xno{1}}^{\xno{2}}
\left(\frac{x - \xno{1}}{h}\right)^2\dx +
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right)^2\dx
= \frac{2h}{3}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="og&#243;lna-posta&#263;-wzoru-na-warto&#347;&#263;-elementu-a-ij-rysunek">Og&#243;lna posta&#263; wzoru na warto&#347;&#263; elementu \( A_{ij} \) - rysunek </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 40</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_i_im1.png" width="500" align="bottom"></p>
</center>

$$ A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}\dx = \hbox{?}$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="og&#243;lna-posta&#263;-wzoru-na-warto&#347;&#263;-elementu-a-ij-obliczenia">Og&#243;lna posta&#263; wzoru na warto&#347;&#263; elementu \( A_{ij} \) - obliczenia </h2>

$$
\begin{align*}
A_{i,i-1} &= \int_\Omega \basphi_i\basphi_{i-1}\dx\\ 
&=
\underbrace{\int_{\xno{i-2}}^{\xno{i-1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_i=0} +
\int_{\xno{i-1}}^{\xno{i}} \basphi_i\basphi_{i-1}\dx +
\underbrace{\int_{\xno{i}}^{\xno{i+1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_{i-1}=0}\\ 
&= \int_{\xno{i-1}}^{\xno{i}}
\underbrace{\left(\frac{x - x_{i}}{h}\right)}_{\basphi_i(x)}
\underbrace{\left(1 - \frac{x - \xno{i-1}}{h}\right)}_{\basphi_{i-1}(x)} \dx =
\frac{h}{6}
\end{align*}
$$


<ul>
 <p><li> \( A_{i,i+1}=A_{i,i-1} \) ze wzgl&#281;du na symetri&#281;</li>
 <p><li> \( A_{i,i}=2h/3 \) (obliczenia jak w przypadku \( A_{2,2} \)), z wyj&#261;tkiem:</li>
 <p><li> \( A_{0,0}=A_{N,N}=h/3 \) (ca&#322;ka tylko na jednym elemencie)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obliczenia-dla-prawej-strony-r&#243;wnania">Obliczenia dla prawej strony r&#243;wnania </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 41</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_i_f.png" width="500" align="bottom"></p>
</center>

$$
b_i = \int_\Omega\basphi_i(x)f(x)\dx
= \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)\dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)
\dx
$$

<p>Do dalszych oblicze&#324; potrzebna konkretna posta&#263; \( f(x) \) ...</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-rozwi&#261;zanie-dla-obszaru-dwu-elementowego-ndash-url-i-rozwi&#261;zanie">Przyk&#322;ad: rozwi&#261;zanie dla obszaru dwu-elementowego &ndash; URL i rozwi&#261;zanie </h2>

<ul>
 <p><li> \( f(x)=x(1-x) \) na \( \Omega=[0,1] \)</li>
 <p><li> Dwa elementy o jednakowej d&#322;ugo&#347;ci: \( [0,0.5] \) oraz \( [0.5,1] \)</li>
</ul>
$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)
\end{equation*}
$$


$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2
\end{equation*}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-rozwi&#261;zanie-dla-obszaru-dwu-elementowego-ndash-rozwi&#261;zanie-rysunek">Przyk&#322;ad: rozwi&#261;zanie dla obszaru dwu-elementowego &ndash; rozwi&#261;zanie-rysunek </h2>
$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$


<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 42</p>
</center>
<p><img src="../fig/fe_p1_x2_2e.png" width="600" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-rozwi&#261;zanie-dla-obszaru-4-elementowego-ndash-rozwi&#261;zanie-rysunek">Przyk&#322;ad: Rozwi&#261;zanie dla obszaru 4-elementowego &ndash; rozwi&#261;zanie-rysunek </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 43</p>
</center>
<p><img src="../fig/fe_p1_x2_2e_4e.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-elementy-typu-p2">Przyk&#322;ad: elementy typu P2 </h2>


<!-- begin box -->
<div style="width:95%; padding:10px; border:1px solid #000; border-radius:4px; ">
<p>Przypomnienie: je&#347;li \( f\in V \), \( u \) odtworzy rozwi&#261;zanie bezb&#322;&#281;dnie.
Je&#347;li \( f \) to parabola, dowolna siatka element&#243;w typu P2 (1 lub wiele element&#243;w)
sprawi wygeneruje \( u=f \).
To samo dotyczy&#263; b&#281;dzie element&#243;w typu P3, P4, itd., poniewa&#380; one wszystkie
potrafi&#261; odtworzy&#263; wielomian 2. stopnia bezb&#322;&#281;dnie.
</p>
</div>
<!-- end box -->


<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="fem:approx:fe:elementwise">Generowanie macierzy globalnej - logika oblicze&#324;</h1>

<p>(ang. assemble - gromadzi&#263;, sk&#322;ada&#263;, zbiera&#263;)</p>

<p>assembling, assemblacja?</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 44</p>
</center>
<p><img src="../mov/fe_assembly_irregular/fe_assembly_irregular.png" width="300" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="ca&#322;kowanie-z-perspektywy-elementu">Ca&#322;kowanie z perspektywy elementu </h2>

$$
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx =
\sum_{e} \int_{\Omega^{(e)}} \basphi_i\basphi_jdx,\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx
$$

<p>Wa&#380;ne spostrze&#380;enia:</p>

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) wtedy i tylko wtedy gdy w&#281;ze&#322;y \( i \) oraz \( j \) le&#380;&#261; na tym samym elemencie \( e \) (w przeciwnym wypadku no&#347;niki funkcji to zbiory roz&#322;&#261;czne)</li>
 <p><li> Wszystkie niezerowe wsp&#243;&#322;czynniki danego elementu \( A^{(e)}_{i,j} \) tworz&#261; lokaln&#261; macierz dla danego elementu (<em>element matrix</em>)</li>
 <p><li> ''Wk&#322;ad'' w macierz lokaln&#261; elementu  maj&#261; wy&#322;&#261;cznie funkcje bazowe zwi&#261;zane z w&#281;z&#322;ami le&#380;&#261;cymi na tym elemencie</li>
 <p><li> Wygodne rozwi&#261;zanie: wprowadzenie <em>indeksacji lokalnej</em> w&#281;z&#322;&#243;w le&#380;&#261;cych na danym elemencie: \( 0,1,\ldots,d \)</li>
</ul>
<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 45</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_i_im1.png" width="300" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="macierz-element&#243;w-indeksacja-lokalna-indeksacja-globalna">Macierz element&#243;w: indeksacja lokalna/indeksacja globalna </h2>

$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,
\quad r,s\in\Ifd=\{0,\ldots,d\}
$$


<!-- !bslidecell 00 0.85 -->

<ul>
 <p><li> \( r,s \) <em>lokalne indeksy w&#281;z&#322;&#243;w</em> na elemencie: \( 0, 1,\ldots, d \)</li>
 <p><li> \( i,j \) <em>globalne indeksy w&#281;z&#322;&#243;w</em> \( i,j\in\If = \{0,1,\ldots,N\} \)</li>
 <p><li> \( i=q(e,r) \): transformacja lokalnej indeksacji w globaln&#261;  (matematyczny zapis pythonowskiego <code>i=elements[e][r]</code>) gdzie:  <code>elements = [[1, 2],[2,3],[3,4], ..., [7,8],[8,9,10], ...]</code></li>
 <p><li> Uwzgl&#281;dnienie macierzy lokalnej \( \tilde A^{(e)}_{r,s} \) w macierzy globalnej \( A_{i,j} \) (<em>assembly</em>)</li>
</ul>
$$
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd
$$


<!-- !eslidecell -->

<!-- !bslidecell 01 0.15 -->

<table class="dotable" border="1">
<thead>
<tr><th align="center">     i      </th> <th align="center">     e      </th> <th align="center">     r      </th> </tr>
</thead>
<tbody>
<tr><td align="right">   1               </td> <td align="right">   1               </td> <td align="right">   1               </td> </tr>
<tr><td align="right">   2               </td> <td align="right">   1               </td> <td align="right">   2               </td> </tr>
<tr><td align="right">   2               </td> <td align="right">   2               </td> <td align="right">   1               </td> </tr>
<tr><td align="right">   3               </td> <td align="right">   2               </td> <td align="right">   2               </td> </tr>
<tr><td align="right">   \( \vdots \)    </td> <td align="right">   \( \vdots \)    </td> <td align="right">   \( \vdots \)    </td> </tr>
<tr><td align="right">   8               </td> <td align="right">   7               </td> <td align="right">   2               </td> </tr>
<tr><td align="right">   8               </td> <td align="right">   8               </td> <td align="right">   1               </td> </tr>
<tr><td align="right">   9               </td> <td align="right">   8               </td> <td align="right">   2               </td> </tr>
<tr><td align="right">   10              </td> <td align="right">   8               </td> <td align="right">   3               </td> </tr>
<tr><td align="right">   10              </td> <td align="right">   9               </td> <td align="right">   1               </td> </tr>
<tr><td align="right">   \( \vdots \)    </td> <td align="right">   \( \vdots \)    </td> <td align="right">   \( \vdots \)    </td> </tr>
</tbody>
</table>

<!-- !eslidecell -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-assembling-macierzy-dla-kolejno-ponumerowanych-element&#243;w-p1">Przyk&#322;ad: assembling macierzy dla kolejno ponumerowanych element&#243;w P1 </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 46</p>
</center>
<p><img src="../mov/fe_assembly_regular_2x2/fe_assembly_regular_2x2.png" width="400" align="bottom"></p>
</center>

<p>TODO</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-assembling-macierzy-dla-kolejno-ponumerowanych-element&#243;w-p3">Przyk&#322;ad: assembling macierzy dla kolejno ponumerowanych element&#243;w P3 </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 47</p>
</center>
<p><img src="../mov/fe_assembly_regular_4x4/fe_assembly_regular_4x4.png" width="400" align="bottom"></p>
</center>

<p>TODO</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<!-- ===== Illustration of the matrix assembly: irregularly numbered P1 elements ===== -->
<h2 id="przyk&#322;ad-assembling-macierzy-dla-nieregularnej-siatki-element&#243;w-p1">Przyk&#322;ad: assembling macierzy dla nieregularnej siatki element&#243;w P1 </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 48</p>
</center>
<p><img src="../mov/fe_assembly_irregular/fe_assembly_irregular.png" width="400" align="bottom"></p>
</center>

<p>TODO</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="assembling-prawej-strony-uk&#322;adu">Assembling prawej strony uk&#322;adu </h2>

$$
b_i = \int_\Omega f(x)\basphi_i(x)dx =
\sum_{e} \int_{\Omega^{(e)}} f(x)\basphi_i(x)dx,\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx
$$


<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 49</p>
</center>
<p><img src="../fig/fe_mesh1D_phi_i_f.png" width="300" align="bottom"></p>
</center>

<p>Wa&#380;ne spostrze&#380;enia:</p>
<ul>
  <p><li> \( b_i^{(e)}\neq 0 \) wtedy i tylko wtedy gdy w&#281;ze&#322; globalny \( i \) le&#380;y na danym elemencie \( e \) (w przeciwnym przypadku \( \basphi_i=0 \))</li>
  <p><li> \( d+1 \) niezerowych warto&#347;ci \( b_i^{(e)} \) mo&#380;e by&#263; zgromadzonych w <em>lokalnym wektorze</em> elementu e. \( \tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\} \), \( r\in\Ifd \)</li>
</ul>
<p>Assembling:</p>
$$
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r\in\Ifd
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="fem:approx:fe:mapping">Transformacja wsp&#243;&#322;rz&#281;dnych globalnych do wsp&#243;&#322;rz&#281;dnych unormowanych</h1>

<p>Normalizacja wsp&#243;&#322;rz&#281;dnych po&#322;o&#380;enia:</p>

<p>Zamiast ca&#322;kowa&#263; w granicach \( [x_L, x_R] \)</p>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{x_L}^{x_R}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
\end{equation*}
$$

<p>mo&#380;na transformowa&#263; przedzia&#322; \( [x_L, x_R] \)
na przedzia&#322; unormowany \( [-1,1] \) o wsp&#243;&#322;rz&#281;dnej lokalnej \( X \)
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="transformacja-liniowa-x-in-1-1-w-x-in-x-l-x-r">Transformacja liniowa \( X\in [-1,1] \) w \( x\in [x_L,x_R] \) </h2>

<p>(Transformacja afiniczna)</p>

$$
x = \half (x_L + x_R) + \half (x_R - x_L)X
$$

<p>inaczej</p>
$$
x = x_m + {\half}hX, \qquad x_m=(x_L+x_R)/2,\quad h=x_R-x_L
$$

<p>Transformacja odwrotna:</p>
$$
X = \frac{2 x + (x_L + x_R)}{(x_R - x_L)} 
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="transformacja-ca&#322;ki">Transformacja ca&#322;ki </h2>
<p>Zmiana granic ca&#322;kowania ->
ca&#322;kowanie na przedziale unormowanym:
podstawienie \( x(X) \) w miejsce \( x \).
</p>

<p>Lokalne funkcje bazowe we wsp&#243;&#322;rz&#281;dnych unormowanych:</p>
$$
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
$$

$$
\begin{array}{c}
x = \half (x_L + x_R) + \half (x_R - x_L)X \\ 
\downarrow \\ 
dx = \half (x_R - x_L) dX
\end{array}
$$


$$
\tilde A^{(e)}_{r,s}
=
\int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
=
\int\limits_{-1}^1 \refphi_r(X)\refphi_s(X)\underbrace{\frac{dx}{dX}}_{\det J= h/2}dX $$

$$
\tilde A^{(e)}_{r,s}
=
\int\limits_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
$$

$$
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int\limits_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="zalety-ca&#322;kowania-na-przedziale-unormowanym">Zalety ca&#322;kowania na przedziale unormowanym </h2>

<ul>
  <p><li> Ca&#322;kowanie zawsze w tych samych granicach ca&#322;kowania \( [-1,1] \)</li>
  <p><li> Potrzebne wzory tylko dla \( \refphi_r(X) \) na jednym elemencie  (brak funkcji definiowanych na przedzia&#322;ach (piecewise polynomial))</li>
  <p><li> Funkcja \( \refphi_r(X) \) jest taka sama dla wszystkich element&#243;w niezale&#380;nie od ich po&#322;o&#380;enia i rozmiar&#243;w (d&#322;ugo&#347;ci). D&#322;ugo&#347;&#263; odcinka jest uwzgl&#281;dniona poprzez jakobian \( \det J \)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="funkcje-bazowe-p1-na-elemencie-unormowanym">Funkcje bazowe P1 na elemencie unormowanym </h2>

$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\label{fem:approx:fe:mapping:P1:phi0}\\ 
\refphi_1(X) &= \half (1 + X)
\label{fem:approx:fe:mapping:P1:phi1}
\end{align}
$$

<p>(proste funkcje wielomianowe zamiast definicji funkcji na podprzedzia&#322;ach</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="funkcje-bazowe-p2-na-elemencie-unormowanym">Funkcje bazowe P2 na elemencie unormowanym </h2>

$$
\begin{align}
\refphi_0(X) &= \half (X-1)X
\label{_auto7}\\ 
\refphi_1(X) &= 1 - X^2
\label{_auto8}\\ 
\refphi_2(X) &= \half (X+1)X
\label{_auto9}
\end{align}
$$

<p>&#321;atwo&#347;&#263; wygenerowania element&#243;w dowolnego rz&#281;du... Jak?</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="sposoby-znalezienia-wzor&#243;w-na-funkcje-bazowe">Sposoby znalezienia wzor&#243;w na funkcje bazowe </h2>

<ol>
<p><li> Transformacja globalnych funkcji bazowych \( \basphi_i(x) \) na element unormowany ze wsp&#243;&#322;rz&#281;dn&#261; \( X \)</li>
<p><li> Obliczenie \( \refphi_r(X) \)</li> 
<ul>
   <p><li> dla zadanego stopnia \( d \) szukamy wielomian&#243;w opartych o w&#281;z&#322;y wewn&#261;trz przedzia&#322;u \( [-1,1] \) o w&#322;asno&#347;ci</li>
<ul>
     <p><li> \( \refphi_r(X)=1 \) w w&#281;&#378;le \( r \)</li>
     <p><li> \( \refphi_r(X)=0 \) we wszystkich pozosta&#322;ych \( d \) w&#281;z&#322;ach</li>
</ul>
</ul>
<p><li> Wykorzystanie wzoru interpolacyjnego Lagrange'a</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:fe:intg:ref">Ca&#322;kowanie po elemencie unormowanym - lokalna macierz</h2>

<p>Za&#322;o&#380;enie: elementy typu P1, oraz funkcja \( f(x)=x(1-x) \).</p>

$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1-X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3}
\label{fem:approx:fe:intg:ref:Ae00}\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6}
\label{_auto10}\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0}
\label{fem:approx:fe:intg:ref:Ae10}\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\label{fem:approx:fe:intg:ref:Ae11}
\end{align}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="ca&#322;kowanie-po-elemencie-unormowanym-wektor-prawej-strony">Ca&#322;kowanie po elemencie unormowanym - wektor prawej strony </h2>

$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \half h x_{m}^{2} + \half h x_{m}
\label{fem:approx:fe:intg:ref:be0}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\half h x_{m}^{2} + \half h x_{m}
\label{_auto11}
\end{align}
$$

<p>\( x_m \): &#347;rodek elementu</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obliczenia-symboliczne-zamiast-&#380;mudnego-liczenia-na-kartce">Obliczenia symboliczne zamiast &#380;mudnego liczenia na kartce... </h2>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, x_m, h, X <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x x_m h X&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> sym<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1-</span>X)<span style="color: #666666">**2</span>, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sym<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1+</span>X)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> x_m <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>X
<span style="color: #666666">&gt;&gt;&gt;</span> b_0 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/4*</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">print</span> b_0
<span style="color: #666666">-</span>h<span style="color: #666666">**3/24</span> <span style="color: #666666">+</span> h<span style="color: #666666">**2*</span>x_m<span style="color: #666666">/6</span> <span style="color: #666666">-</span> h<span style="color: #666666">**2/12</span> <span style="color: #666666">-</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">**2/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">/2</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="implementacja">Implementacja </h1>

<ul>
 <p><li> Funkcje przedstawione na kolejnych slajdach znajduj&#261; sie w module <code>fe_approx1D.py</code></li>
 <p><li> Przedstawione funkcje dzia&#322;aj&#261; w trybie symbolicznym, jak i numerycznym</li>
 <p><li> Kod zawiera wszystkie kroku oblicze&#324; elementami sko&#324;czonymi.</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="generowanie-funkcji-bazowych-na-przedziale-unormowanymi">Generowanie funkcji bazowych na przedziale unormowanymi </h2>

<p>Niech \( \refphi_r(X) \) b&#281;dzie wielomianem Lagrange'a stopnia <code>d</code>:</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">phi_r</span>(r, X, d):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(X, sym<span style="color: #666666">.</span>Symbol):
        h <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>, d)  <span style="color: #408080; font-style: italic"># node spacing</span>
        nodes <span style="color: #666666">=</span> [<span style="color: #666666">2*</span>i<span style="color: #666666">*</span>h <span style="color: #666666">-</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)]
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #408080; font-style: italic"># assume X is numeric: use floats for nodes</span>
        nodes <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, d<span style="color: #666666">+1</span>)
    <span style="color: #008000; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lagrange_polynomial</span>(x, i, points):
    p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(points)):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #666666">!=</span> i:
            p <span style="color: #666666">*=</span> (x <span style="color: #666666">-</span> points[k])<span style="color: #666666">/</span>(points[i] <span style="color: #666666">-</span> points[k])
    <span style="color: #008000; font-weight: bold">return</span> p

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">basis</span>(d<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return the complete basis.&quot;&quot;&quot;</span>
    X <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;X&#39;</span>)
    phi <span style="color: #666666">=</span> [phi_r(r, X, d) <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)]
    <span style="color: #008000; font-weight: bold">return</span> phi
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obliczanie-wsp&#243;&#322;czynnik&#243;w-macierzy">Obliczanie wsp&#243;&#322;czynnik&#243;w macierzy </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_matrix</span>(phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    A_e <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((n, n))
    X <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;X&#39;</span>)
    <span style="color: #008000; font-weight: bold">if</span> symbolic:
        h <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;h&#39;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #408080; font-style: italic"># dx/dX</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(r, n):
            A_e[r,s] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi[r]<span style="color: #666666">*</span>phi[s]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
            A_e[s,r] <span style="color: #666666">=</span> A_e[r,s]
    <span style="color: #008000; font-weight: bold">return</span> A_e
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-obliczenia-macierzy-wsp&#243;&#322;czynnik&#243;w-symbolicznie-vs-numerycznie">Przyk&#322;ad: Obliczenia macierzy wsp&#243;&#322;czynnik&#243;w: symbolicznie vs numerycznie </h2>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> phi
[<span style="color: #666666">1/2</span> <span style="color: #666666">-</span> X<span style="color: #666666">/2</span>, <span style="color: #666666">1/2</span> <span style="color: #666666">+</span> X<span style="color: #666666">/2</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> element_matrix(phi, Omega_e<span style="color: #666666">=</span>[<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>], symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
[h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> element_matrix(phi, Omega_e<span style="color: #666666">=</span>[<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>], symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
[<span style="color: #666666">0.0333333333333333</span>, <span style="color: #666666">0.0166666666666667</span>]
[<span style="color: #666666">0.0166666666666667</span>, <span style="color: #666666">0.0333333333333333</span>]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obliczenia-wsp&#243;&#322;czynnik&#243;w-wektora-prawej-strony">Obliczenia wsp&#243;&#322;czynnik&#243;w wektora prawej strony </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_vector</span>(f, phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    b_e <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((n, <span style="color: #666666">1</span>))
    <span style="color: #408080; font-style: italic"># Make f a function of X</span>
    X <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;X&#39;</span>)
    <span style="color: #008000; font-weight: bold">if</span> symbolic:
        h <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;h&#39;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    x <span style="color: #666666">=</span> (Omega_e[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> Omega_e[<span style="color: #666666">1</span>])<span style="color: #666666">/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>X  <span style="color: #408080; font-style: italic"># mapping</span>
    f <span style="color: #666666">=</span> f<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;x&#39;</span>, x)  <span style="color: #408080; font-style: italic"># substitute mapping formula for x</span>
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #408080; font-style: italic"># dx/dX</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        b_e[r] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
    <span style="color: #008000; font-weight: bold">return</span> b_e
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Zwr&#243;&#263; uwag&#281; na <code>f.subs('x', x)</code> -> podstawienie \( x(X) \) za <code>x</code> w formule na <code>f</code>
(od teraz <code>f</code> jest funkcj&#261; \( f(X) \))
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="powr&#243;t-do-ca&#322;kowania-numerycznego-w-razie-niepowodzenia-ca&#322;kowania-symbolicznego-int-f-refphi-r-dx">Powr&#243;t do ca&#322;kowania numerycznego w razie niepowodzenia ca&#322;kowania symbolicznego \( \int f\refphi_r dx \) </h2>

<ul>
  <p><li> Macierz lewej strony: tylko wielomiany -> <code>sympy</code> zawsze da rad&#281;</li>
  <p><li> Wektor prawej strony: ca&#322;kowanie \( \int f\refphi \dx \) mo&#380;e si&#281; nie powie&#347;&#263; (<code>sympy</code> zwr&#243;ci obiekt typu <code>Integral</code> zamiast liczby)</li>
</ul>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_vector</span>(f, phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
        <span style="color: #666666">...</span>
        I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))  <span style="color: #408080; font-style: italic"># try...</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]  <span style="color: #408080; font-style: italic"># Ensure h is numerical</span>
            detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([X], f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>])
        b_e[r] <span style="color: #666666">=</span> I
        <span style="color: #666666">...</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="assembling-url-i-rozwi&#261;zanie">Assembling URL i rozwi&#261;zanie </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">assemble</span>(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>):
    N_n, N_e <span style="color: #666666">=</span> <span style="color: #008000">len</span>(nodes), <span style="color: #008000">len</span>(elements)
    zeros <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros <span style="color: #008000; font-weight: bold">if</span> symbolic <span style="color: #008000; font-weight: bold">else</span> np<span style="color: #666666">.</span>zeros
    A <span style="color: #666666">=</span> zeros((N_n, N_n))
    b <span style="color: #666666">=</span> zeros((N_n, <span style="color: #666666">1</span>))
    <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e):
        Omega_e <span style="color: #666666">=</span> [nodes[elements[e][<span style="color: #666666">0</span>]], nodes[elements[e][<span style="color: #666666">-1</span>]]]

        A_e <span style="color: #666666">=</span> element_matrix(phi, Omega_e, symbolic)
        b_e <span style="color: #666666">=</span> element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(elements[e])):
            <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
            b[elements[e][r]] <span style="color: #666666">+=</span> b_e[r]
    <span style="color: #008000; font-weight: bold">return</span> A, b
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="rozwi&#261;zanie-url">Rozwi&#261;zanie URL </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">if</span> symbolic:
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)           <span style="color: #408080; font-style: italic"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #008000; font-weight: bold">else</span>:
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)  <span style="color: #408080; font-style: italic"># numpy arrays, numerical solve</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Uwaga: obliczanie wsp&#243;&#322;czynnik&#243;w macierzy <code>A</code>, <code>b</code> oraz rozwi&#261;zanie URL
<code>A.LUsolve(b)</code> mo&#380;e by&#263; baaardzo czasoch&#322;onne$\ldots$
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-generowanie-macierzy-symbolicznie">Przyk&#322;ad: generowanie macierzy symbolicznie </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> h, x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;h x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, h, <span style="color: #666666">2*</span>h]
<span style="color: #666666">&gt;&gt;&gt;</span> elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,   <span style="color: #666666">0</span>]
[h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[  <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> b
[     h<span style="color: #666666">**2/6</span> <span style="color: #666666">-</span> h<span style="color: #666666">**3/12</span>]
[      h<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">7*</span>h<span style="color: #666666">**3/6</span>]
[<span style="color: #666666">5*</span>h<span style="color: #666666">**2/6</span> <span style="color: #666666">-</span> <span style="color: #666666">17*</span>h<span style="color: #666666">**3/12</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #666666">&gt;&gt;&gt;</span> c
[                           h<span style="color: #666666">**2/6</span>]
[<span style="color: #666666">12*</span>(<span style="color: #666666">7*</span>h<span style="color: #666666">**2/12</span> <span style="color: #666666">-</span> <span style="color: #666666">35*</span>h<span style="color: #666666">**3/72</span>)<span style="color: #666666">/</span>(<span style="color: #666666">7*</span>h)]
[  <span style="color: #666666">7*</span>(<span style="color: #666666">4*</span>h<span style="color: #666666">**2/7</span> <span style="color: #666666">-</span> <span style="color: #666666">23*</span>h<span style="color: #666666">**3/21</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>h)]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-generowanie-macierzy-numerycznie">Przyk&#322;ad: generowanie macierzy numerycznie </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[ <span style="color: #666666">0.166666666666667</span>, <span style="color: #666666">0.0833333333333333</span>,                  <span style="color: #666666">0</span>]
[<span style="color: #666666">0.0833333333333333</span>,  <span style="color: #666666">0.333333333333333</span>, <span style="color: #666666">0.0833333333333333</span>]
[                 <span style="color: #666666">0</span>, <span style="color: #666666">0.0833333333333333</span>,  <span style="color: #666666">0.166666666666667</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> b
[          <span style="color: #666666">0.03125</span>]
[<span style="color: #666666">0.104166666666667</span>]
[          <span style="color: #666666">0.03125</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #666666">&gt;&gt;&gt;</span> c
[<span style="color: #666666">0.0416666666666666</span>]
[ <span style="color: #666666">0.291666666666667</span>]
[<span style="color: #666666">0.0416666666666666</span>]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:fe:A:structure">Struktura macierzy wsp&#243;&#322;czynnik&#243;w</h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> d<span style="color: #666666">=1</span>; N_e<span style="color: #666666">=8</span>; Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]  <span style="color: #408080; font-style: italic"># 8 linear elements on [0,1]</span>
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> nodes, elements <span style="color: #666666">=</span> mesh_symbolic(N_e, d, Omega)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Uwaga (zadanie domowe): Wykonaj obliczenia na kartce papieru
w celu potwierdzenia warto&#347;ci poszczeg&#243;lnych element&#243;w powy&#380;szej macierzy
(pomocne w zrozumieniu materia&#322;u).
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wynik-w-przypadku-og&#243;lnym-n-jednakowych-element&#243;w">Wynik w przypadku og&#243;lnym (\( N \) jednakowych element&#243;w) </h2>

<ul>
 <p><li> Macierz rzadka -> wi&#281;kszo&#347;&#263; wsp&#243;&#322;czynnik&#243;w to zera</li>
 <p><li> Przyk&#322;ad dla element&#243;w typu P1, siatka regularna</li>
</ul>
$$
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="macierz-rzadka-dla-element&#243;w-typu-p2-siatka-regularna">Macierz rzadka  dla element&#243;w typu P2 (siatka regularna) </h2>

$$
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 & 0\\ 
  0 & 0 & 2 & 16 & 2 & 0 & 0 & 0 & 0\\ 
  0 & 0 & - 1 & 2 & 8 & 2 & - 1 & 0 & 0\\ 
  0 & 0 & 0 & 0 & 2 & 16 & 2 & 0 & 0\\ 
  0 & 0 & 0 & 0 & - 1 & 2 & 8 & 2 & - 1
  \\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="macierz-rzadka-dla-siatek-regularnych-indeksowanych-losowo-dla-element&#243;w-p1">Macierz rzadka dla siatek regularnych/indeksowanych losowo dla element&#243;w P1 </h2>

<ul>
 <p><li> Po lewej: w&#281;z&#322;y i elementy ideksowane od lewej do prawej</li>
 <p><li> Po prawej: w&#281;z&#322;y i elementy indeksowane ''losowo''</li>
</ul>
<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 50</p>
</center>
<p><img src="../fig/sparsity_pattern_1D_30.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="macierz-rzadka-dla-siatek-regularnych-indeksowanych-losowo-dla-element&#243;w-p3">Macierz rzadka dla siatek regularnych/indeksowanych losowo dla element&#243;w P3 </h2>

<ul>
 <p><li> Po lewej: w&#281;z&#322;y i elementy ideksowane od lewej do prawej</li>
 <p><li> Po prawej: w&#281;z&#322;y i elementy indeksowane ''losowo''</li>
</ul>
<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 51</p>
</center>
<p><img src="../fig/sparsity_pattern_1DP3_30.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="macierze-rzadkie-ndash-podsumowanie">Macierze rzadkie &ndash; podsumowanie </h2>
<div id="fem:approx:fe:impl:sparse"></div>

<p>Posta&#263; specyficznych macierzy \( A_{i,j} \):</p>

<ul>
 <p><li> Elementy P1: 3 niezerowe elementy w wierszu</li>
 <p><li> Elementy P2: 5 niezerowe elementy w wierszu</li>
 <p><li> Elementy P3: 7 niezerowe elementy w wierszu</li>
</ul>
<p>Wskaz&#243;wki:</p>

<ul>
 <p><li> Nale&#380;y u&#380;ywa&#263; specjalne techniki przechowywania takich macierzy w pami&#281;ci i specjalnych solver&#243;w dla macierzy rzadkich</li>
 <p><li> W Pythonie: pakiet <code>scipy.sparse</code></li> 
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-przybli&#380;enie-funkcji-f-sim-x-9-elementami-r&#243;&#380;nego-typu-kod">Przyk&#322;ad: przybli&#380;enie funkcji \( f\sim x^9 \) elementami r&#243;&#380;nego typu; kod </h2>

<p>Zadanie:
Por&#243;wna&#263; rozwi&#261;zanie zadania przybli&#380;enia funkcji \( f(x) \) przy pomocy siatki
\( N_e \) element&#243;w sko&#324;czonych o funkcjach bazowych rz&#281;du \( d \).
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #008000; font-weight: bold">import</span> approximate
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>, d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=4</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>, d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=2</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>, d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=8</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>, d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=4</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-przybli&#380;enie-funkcji-f-sim-x-9-elementami-r&#243;&#380;nego-typu-rysunki">Przyk&#322;ad: przybli&#380;enie funkcji \( f\sim x^9 \) elementami r&#243;&#380;nego typu; rysunki </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 52</p>
</center>
<p><img src="../fig/fe_p1_p2_x9_248e.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>

<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="fem:approx:fe:limitations">Ograniczenia zaprezentowanego podej&#347;cia element&#243;w sko&#324;czonych</h1>

<p>Najcz&#281;stsza interpretacja:</p>

<ul>
 <p><li> <em>W&#281;z&#322;y</em>: punkty potrzebne do zdefiniowania \( \basphi_i \) i obliczania</li>
</ul>
<p>warto&#347;ci \( u \) (wymagane do geometrii i aproksymacji funkcji)</p>
<ul>
 <p><li> <em>Elementy</em>: podobszary (zawieraj&#261;ce kilka w&#281;z&#322;&#243;w)</li>
</ul>
<p>Problem:</p>

<ul>
 <p><li> w&#281;z&#322;y na brzegu potrzebne przy warunkach brzegowych, a nie zawsze tak musi by&#263; dla szczeg&#243;lnych rodzaj&#243;w interpolacji (np. elementy sta&#322;e)</li>
 <p><li> Trzeba wymy&#347;le&#263; co&#347; lepszego...</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:fe:element">Uog&#243;lnienie koncepcji elementu sko&#324;czonego (kom&#243;rki, wierzcho&#322;ki, w&#281;z&#322;y, stopnie swobody)</h2>

<ul>
 <p><li> Rozdzielenie aproksymacji geometrii (obszaru) od aproksymacji funkcji ''nad'' obszarem</li>
 <p><li> Nowe poj&#281;cia: <em>kom&#243;rka</em> (ang. cell) &ndash; podobszar, element, kawa&#322;ek obszaru</li>
 <p><li> Kom&#243;rka zbudowana jest z <em>wierzcho&#322;k&#243;w</em> (ang. vertices <- vertex) &ndash; (kra&#324;c&#243;w przedzia&#322;u w 1D)</li> 
 <p><li> <em>W&#281;z&#322;y</em> (ang. nodes) p- punkty, w kt&#243;rych nale&#380;y wyznaczy&#263; warto&#347;&#263; poszukiwanej funkcji (nie musz&#261; pokrywa&#263; si&#281; z wierzcho&#322;kami!, ale mog&#261;\ldots)</li>
 <p><li> <em>Stopnie swobody</em> (ang. degrees of freedom)
<p>    &ndash; wielko&#347;ci reprezentowane przez \( c_j \)
    (niewiadome w URL) -> najcz&#281;&#347;ciej: warto&#347;ci funkcji w w&#281;&#378;le
    \( \sum_{j\in\If} c_j \basphi_j(\xno{i}) = c_i \)
</p></li>
</ul>
<p>wierzcho&#322;ki -> kom&#243;rki -> interpolacja geometrii</p>

<p>w&#281;z&#322;y, stopnie swobody -> interpolacja funkcji </p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="poj&#281;cie-elementu-sko&#324;czonego">Poj&#281;cie elementu sko&#324;czonego </h2>

<ol>
 <p><li> <em>kom&#243;rka odniesienia</em> z unormowanym, lokalnym uk&#322;adem wsp&#243;&#322;rz&#281;dnych</li>
 <p><li> zbi&#243;r  <em>funkcji bazowych</em> \( \refphi_r \) dla kom&#243;rki</li>
 <p><li> zbi&#243;r <em>stopni swobody</em> (t.j. warto&#347;ci funkcji), jednoznacznie wyznaczaj&#261;cy funkcje bazowe, dobrane tak aby \( \refphi_r=1 \) dla \( r \)-tego stopnia swobody oraz \( \refphi_r=0 \) dla wszystkich pozosta&#322;ych stopni swobody</li>
 <p><li> odwzorowanie (ang. mapping) pomi&#281;dzy lokaln&#261; a globaln&#261; indeksacj&#261; (transformacja numeracji) stopni swobody (<em>odwzorowanie dof</em> &ndash; <em>dof map</em>)</li>
 <p><li> odwzorowanie kom&#243;rki unormowanej na kom&#243;rk&#281; rzeczywistego obszaru  (w 1D: \( [-1,1]\ \Rightarrow\ [x_L,x_R] \))</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:fe:element:impl">Struktury danych: <code>vertices</code>, <code>cells</code>, <code>dof_map</code></h2>

<ul>
  <p><li> Wsp&#243;&#322;rz&#281;dne wierzcho&#322;k&#243;w kom&#243;rek: <code>vertices</code> (r&#243;wnowa&#380;ne strukturze <code>nodes</code> dla element&#243;w P1)</li>
  <p><li> Wierzcho&#322;ki dla element&#243;w (kom&#243;rek): <code>cells[e][r]</code> numer globalny dla wiercho&#322;ka <code>r</code> elementu <code>e</code> (r&#243;wnowa&#380;ne strukturze <code>elements</code> dla element&#243;w typu P1)</li>
  <p><li> <code>dof_map[e,r]</code> odwzorowanie lokalnego indeksu stopnia swobody <code>r</code> elementu <code>e</code> na number globalny (r&#243;wnowa&#380;ne strukturze <code>elements</code> dla element&#243;w typu Pd)</li> 
</ul>
<p>W trakcie assemblingu nale&#380;y skorzysta&#263; ze struktury <code>dof_map</code>:</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">A[dof_map[e][r], dof_map[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
b[dof_map[e][r]] <span style="color: #666666">+=</span> b_e[r]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !bslidecell 00 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 53</p>
</center>
<p><img src="../fig/fe_mesh1D_P2.png" width="500" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !bslidecell 01 -->

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>, <span style="color: #666666">1</span>]
cells <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
dof_map <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>]]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<!-- !eslidecell -->

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ad-elementy-p0">Przyk&#322;ad: elementy P0 </h2>

<p>Przyk&#322;ad: Ta sama siatka, ale \( u \) to funkcja sta&#322;a na ka&#380;dej kom&#243;rce (przedzia&#322;ami sta&#322;a) -> elementy typu P0.</p>

<p>Te same struktury <code>vertices</code> i <code>cells</code>, ale dodatkowo</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">dof_map <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>], [<span style="color: #666666">1</span>]]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Mo&#380;na traktowa&#263; te elementy jak elementy z interpolacj&#261; opart&#261; na w&#281;&#378;le
znajduj&#261;cym si&#281; po&#347;rodku elementu.
</p>

<div class="alert alert-block alert-block alert-text-normal">
<b>Uwaga:</b>
<p>
<p>Od tej pory b&#281;dziemy wykorzystywa&#263; struktury <code>cells</code>, <code>vertices</code>, i <code>dof_map</code>.</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="szkielet-programu">Szkielet programu </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># Use modified fe_approx1D module</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> x)

N_e <span style="color: #666666">=</span> <span style="color: #666666">10</span>
<span style="color: #408080; font-style: italic"># Create mesh with P3 (cubic) elements</span>
vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(N_e, d<span style="color: #666666">=3</span>, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>])

<span style="color: #408080; font-style: italic"># Create basis functions on the mesh</span>
phi <span style="color: #666666">=</span> [basis(<span style="color: #008000">len</span>(dof_map[e])<span style="color: #666666">-1</span>) <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]

<span style="color: #408080; font-style: italic"># Create linear system and solve it</span>
A, b <span style="color: #666666">=</span> assemble(vertices, cells, dof_map, phi, f)
c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)

<span style="color: #408080; font-style: italic"># Make very fine mesh and sample u(x) on this mesh for plotting</span>
x_u, u <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map,
                resolution_per_element<span style="color: #666666">=51</span>)
plot(x_u, u)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przybli&#380;enie-paraboli-elementami-p0">Przybli&#380;enie paraboli elementami P0 </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 54</p>
</center>
<p><img src="../fig/fe_p0_x2_4e_8e.png" width="800" align="bottom"></p>
</center>

<p>Funkcja <code>approximate</code> ''opakowuje'' polecenia z poprzedniego slajdu:</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
x<span style="color: #666666">=</span>sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&quot;x&quot;</span>)
<span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">4</span>, <span style="color: #666666">8</span>:
    approximate(x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x), d<span style="color: #666666">=0</span>, N_e<span style="color: #666666">=</span>N_e, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:fe:element:impl:error">Obliczanie b&#322;&#281;d&#243;w aproksymacji; uwagi og&#243;lne</h2>

<p>B&#322;&#261;d jako funkcja:</p>

$$ e(x) = f(x) - u(x) $$

<p>B&#322;&#261;d &ndash; dyskretna warto&#347;&#263; -> normy:</p>
$$ L^2 \hbox{ error: }\quad ||e||_{L^2} =
\left(\int_{\Omega} e^2 dx\right)^{1/2}$$

<p>Szacowanie ca&#322;ki:</p>

<ul>
 <p><li> dok&#322;adne, analityczne (symboliczne) - nieuniwersalne -> kwadratury</li>
 <p><li> odpowiednio dok&#322;adne spr&#243;bkowanie \( u(x) \) w wielu punktach ka&#380;dego elementu (np. poprzez wywo&#322;anie <code>u_glob</code>, kt&#243;re zwr&#243;ci <code>x</code> i <code>u</code>), a nast&#281;pnie</li>
 <p><li> sca&#322;kowanie metod&#261; trapez&#243;w</li>
 <p><li> Uwaga! Wa&#380;ne! Ca&#322;ka powinna by&#263; policzona dok&#322;adnie ''po elementach'' (zmienno&#347;&#263; funkcji \( f \))</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obliczanie-b&#322;&#281;d&#243;w-aproksymacji-szczeg&#243;&#322;y">Obliczanie b&#322;&#281;d&#243;w aproksymacji; szczeg&#243;&#322;y </h2>

<div class="alert alert-block alert-warning alert-text-normal">
<b>Uwaga</b>
<p>
<p>Poniewa&#380; elementy mog&#261; by&#263; r&#243;&#380;nych rozmiar&#243;w (d&#322;ugo&#347;ci)
siatka dyskretna mo&#380;e by&#263; niejednorodna, (ponadto powt&#243;rzone punkty
na granicach element&#243;w, widziane z perspektywy dw&#243;ch s&#261;siaduj&#261;cych element&#243;w)
</p>

<p>-></p>

<p>potrzebna prymitywna implementacja wzoru trapez&#243;w:</p>

$$ \int_\Omega g(x) dx \approx \sum_{j=0}^{n-1} \half(g(x_j) +
g(x_{j+1}))(x_{j+1}-x_j)$$
</div>



<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># Given c, compute x and u values on a very fine mesh</span>
x, u <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map,
              resolution_per_element<span style="color: #666666">=101</span>)
<span style="color: #408080; font-style: italic"># Compute the error on the very fine mesh</span>
e <span style="color: #666666">=</span> f(x) <span style="color: #666666">-</span> u
e2 <span style="color: #666666">=</span> e<span style="color: #666666">**2</span>
<span style="color: #408080; font-style: italic"># Vectorized Trapezoidal rule</span>
E <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">0.5*</span>np<span style="color: #666666">.</span>sum((e2[:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> e2[<span style="color: #666666">1</span>:])<span style="color: #666666">*</span>(x[<span style="color: #666666">1</span>:] <span style="color: #666666">-</span> x[:<span style="color: #666666">-1</span>]))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="zale&#380;no&#347;&#263;-b&#322;&#281;du-od-h-i-d">Zale&#380;no&#347;&#263; b&#322;&#281;du od \( h \) i \( d \) </h2>

<p>Teoria i eksperymenty pokazuj&#261;, &#380;e aplikacja \( \LSM \) czy metody Galerkina
dla element&#243;w sko&#324;czonych typu Pd o tej samej d&#322;ugo&#347;ci \( h \) daje b&#322;&#261;d:
</p>

$$
||e||_{L^2} = C | f^{d+1} | h^{d+1}
$$

<p>gdzie \( C \) zale&#380;y od \( d \) i \( \Omega = [0, L] \) ale nie zale&#380;y od \( h \),
oraz
</p>
$$
|f^{d+1}|^{2} = \int_0^L  \left( \frac{d^{d+1}f}{d x^{d+1}} \right)^2 dx
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kubiczne-wielomiany-hermite-a-definicja">Kubiczne wielomiany Hermite'a - definicja </h2>

<ul>
 <p><li> Czy da si&#281; skonstruowa&#263; \( \basphi_i(x) \) z ci&#261;g&#322;&#261; pochodn&#261;? Tak!</li>
</ul>
<p>Niech dana b&#281;dzie unormowana kom&#243;rka \( [-1,1] \) z dwoma w&#281;z&#322;ami \( X=-1 \) i \( X=1 \).
Stopnie swobody:
</p>

<ul>
  <p><li> 0: warto&#347;&#263; funkcji w \( X=-1 \)</li>
  <p><li> 1: warto&#347;&#263; pierwszej pochodnej w \( X=-1 \)</li>
  <p><li> 2: warto&#347;&#263; funkcji w \( X=1 \)</li>
  <p><li> 3: warto&#347;&#263; pierwszej pochodnej w \( X=1 \)</li>
</ul>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Uwzgl&#281;dnienie warto&#347;ci pochodnych zadanej funkcji w w&#281;z&#322;ach
jako stopni swobody zapewnia kontrol&#281; ci&#261;g&#322;o&#347;ci pochodnej.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kubiczne-wielomiany-hermite-a-wyprowadzenie">Kubiczne wielomiany Hermite'a - wyprowadzenie </h2>

<p>4 ogranicznia na \( \refphi_r \) (1 dla stopnia swobody \( r \), 0 dla pozosta&#322;ych):</p>

<ul>
  <p><li> \( \refphi_0(\Xno{0}) = 1 \), \( \refphi_0(\Xno{1}) = 0 \), \( \refphi_0'(\Xno{0}) = 0 \), \( \refphi_0'(\Xno{1}) = 0 \)</li>
  <p><li> \( \refphi_1'(\Xno{0}) = 1 \), \( \refphi_1'(\Xno{1}) = 0 \), \( \refphi_1(\Xno{0}) = 0 \), \( \refphi_1(\Xno{1}) = 0 \)</li>
  <p><li> \( \refphi_2(\Xno{1}) = 1 \), \( \refphi_2(\Xno{0}) = 0 \), \( \refphi_2'(\Xno{0}) = 0 \), \( \refphi_2'(\Xno{1}) = 0 \)</li>
  <p><li> \( \refphi_3'(\Xno{1}) = 1 \), \( \refphi_3'(\Xno{0}) = 0 \), \( \refphi_3(\Xno{0}) = 0 \), \( \refphi_3(\Xno{1}) = 0 \)</li>
</ul>
<p>Cztery uk&#322;ady r&#243;wna&#324; liniowych z 4 niewiadomymi -
wsp&#243;&#322;czynnikami wielomian&#243;w 3 stopnia.
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kubiczne-wielomiany-hermite-a-wynik">Kubiczne wielomiany Hermite'a - wynik </h2>

$$
\begin{align}
\refphi_0(X) &= 1 - \frac{3}{4}(X+1)^2 + \frac{1}{4}(X+1)^3
\label{_auto12}\\ 
\refphi_1(X) &= -(X+1)(1 - \half(X+1))^2
\label{_auto13}\\ 
\refphi_2(X) &= \frac{3}{4}(X+1)^2 - \half(X+1)^3
\label{_auto14}\\ 
\refphi_3(X) &= -\half(X+1)(\half(X+1)^2 - (X+1))
\label{_auto15}\\ 
\label{_auto16}
\end{align}
$$


<!-- !split --><br><br><br><br><br><br><br><br>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kubiczne-wielomiany-hermite-a-sprawdzenie">Kubiczne wielomiany Hermite'a - sprawdzenie </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># definition of the interval ends</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>]) 

C <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># list of polynomials stored as coefficients </span>
B <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># list of basis functions</span>
dB <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># list of the derivatives of basis functions</span>

<span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">0</span>,<span style="color: #666666">4</span>):
    A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(  [[   x[<span style="color: #666666">0</span>]<span style="color: #666666">**3</span>,   x[<span style="color: #666666">0</span>]<span style="color: #666666">**2</span>, x[<span style="color: #666666">0</span>], <span style="color: #666666">1</span> ],
                    [ <span style="color: #666666">3*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">**2</span>, <span style="color: #666666">2*</span>x[<span style="color: #666666">0</span>],       <span style="color: #666666">1</span>, <span style="color: #666666">0</span> ],
                    [   x[<span style="color: #666666">1</span>]<span style="color: #666666">**3</span>,   x[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>, x[<span style="color: #666666">1</span>], <span style="color: #666666">1</span> ],
                    [ <span style="color: #666666">3*</span>x[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>, <span style="color: #666666">2*</span>x[<span style="color: #666666">1</span>],       <span style="color: #666666">1</span>, <span style="color: #666666">0</span> ]])

    b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros( (<span style="color: #666666">4</span>,<span style="color: #666666">1</span>) ); b[k] <span style="color: #666666">=</span> <span style="color: #666666">1</span> 
    
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b); C<span style="color: #666666">.</span>append( c )

    B<span style="color: #666666">.</span>append( <span style="color: #008000; font-weight: bold">lambda</span> x:     C[k][<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">*</span> x<span style="color: #666666">**3</span> <span style="color: #666666">+</span>   C[k][<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">*</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> C[k][<span style="color: #666666">2</span>,<span style="color: #666666">0</span>] <span style="color: #666666">*</span> x <span style="color: #666666">+</span> C[k][<span style="color: #666666">3</span>,<span style="color: #666666">0</span>] )
    dB<span style="color: #666666">.</span>append( <span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #666666">3*</span> C[k][<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">*</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>C[k][<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">*</span> x <span style="color: #666666">+</span> C[k][<span style="color: #666666">2</span>,<span style="color: #666666">0</span>] )
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kubiczne-wielomiany-hermite-a-sprawdzenie">Kubiczne wielomiany Hermite'a - sprawdzenie </h2>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># Check numerically that resulting cubic polynomial</span>
<span style="color: #408080; font-style: italic"># fulfills imposed requirements</span>
A <span style="color: #666666">=</span> [<span style="color: #666666">1</span>,       <span style="color: #666666">1</span>,       <span style="color: #666666">2</span>,      <span style="color: #666666">1</span>]      <span style="color: #408080; font-style: italic"># basis function coefficients </span>
<span style="color: #408080; font-style: italic">#    U(x[0])  dU(x[0]) U(x[1]) dU(x[1])</span>

xx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>, <span style="color: #666666">0.001</span>)  
U <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(xx<span style="color: #666666">.</span>shape)

<span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">0</span>,<span style="color: #666666">4</span>):
    U <span style="color: #666666">=</span> U <span style="color: #666666">+</span> A[k] <span style="color: #666666">*</span> B[k](xx)

<span style="color: #408080; font-style: italic"># numerical approximation of the derivatives at the ends of the interval</span>
dl <span style="color: #666666">=</span> (U[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>U[<span style="color: #666666">0</span>])<span style="color: #666666">/</span>(xx[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>xx[<span style="color: #666666">0</span>])
dr <span style="color: #666666">=</span> (U[<span style="color: #666666">-1</span>]<span style="color: #666666">-</span>U[<span style="color: #666666">-2</span>])<span style="color: #666666">/</span>(xx[<span style="color: #666666">-1</span>]<span style="color: #666666">-</span>xx[<span style="color: #666666">-2</span>])

numericalApproximationOfA <span style="color: #666666">=</span> [ U[<span style="color: #666666">0</span>], dl, U[<span style="color: #666666">-1</span>], dr]

<span style="color: #008000">print</span>(numericalApproximationOfA)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Wynik dzia&#322;ania skryptu:</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">[<span style="color: #666666">1.0</span>, <span style="color: #666666">0.9992502500000269</span>, <span style="color: #666666">1.999000749750002</span>, <span style="color: #666666">0.9977517500000526</span>]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kubiczne-wielomiany-hermite-a-wyniki">Kubiczne wielomiany Hermite'a - wyniki </h2>

<!-- !bslidecell 00 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 55</p>
</center>
<p><img src="../figMB/cubicHermiteBasis.png" width="500" align="bottom"></p>
</center>

<!-- !eslidecell -->

<!-- !bslidecell 01 -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 56</p>
</center>
<p><img src="../figMB/cubicHermiteDerivs.png" width="500" align="bottom"></p>
</center>

<!-- !eslidecell -->

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 57</p>
</center>
<p><img src="../figMB/cubicHermiteResult.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="ca&#322;kowanie-numeryczne">Ca&#322;kowanie numeryczne </h1>

<ul>
 <p><li> \( \int_\Omega f\basphi_idx \) - konieczno&#347;&#263; ca&#322;kowania numerycznego</li> 
 <p><li> Wsp&#243;&#322;czynniki macierzy lewej strony - zwykle r&#243;wnie&#380; numerycznie (bo wygodnie)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="og&#243;lna-posta&#263;-kwadratury">Og&#243;lna posta&#263; kwadratury </h2>

$$
\int_{-1}^{1} g(X)dX \approx \sum_{j=0}^M w_jg(\bar X_j),
$$

<p>gdzie</p>

<ul>
 <p><li> \( \bar X_j \) to <em>w&#281;z&#322;y kwadratury</em></li>
 <p><li> \( w_j \) &ndash; <em>wagi kwadratury</em></li>
</ul>
<p>R&#243;&#380;ne metody -> r&#243;&#380;ny wyb&#243;r w&#281;z&#322;&#243;w i wag</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="wz&#243;r-prostok&#261;t&#243;w">Wz&#243;r prostok&#261;t&#243;w </h2>

<p>(ang. midpoint rule) &ndash; metoda punktu &#347;rodkowego</p>

<p>Najprostsza metoda</p>

$$
\int_{-1}^{1} g(X)dX \approx 2g(0),\quad \bar X_0=0,\ w_0=2,
$$

<p>Dok&#322;adna dla funkcji podca&#322;kowych b&#281;d&#261;cych wielomianami 1. stopnia</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:fe:numint1">Metody Newtona-Cotesa</h2>

<ul>
 <p><li> Idea: w&#281;z&#322;y kwadratury r&#243;wnomiernie rozmieszczone na \( [-1,1] \)</li>
 <p><li> W&#281;z&#322;y kwadratury cz&#281;sto pokrywaj&#261; si&#281; w&#281;z&#322;ami siatki
<!-- * Very useful for making \( \basphi_i\basphi_j=0 \) and get diagonal -->
<!-- (&quot;mass&quot;) matrices (&quot;lumping&quot;) --></li>
</ul>
<p>Wz&#243;r trapez&#243;w:</p>

$$
\int_{-1}^{1} g(X)dX \approx g(-1) + g(1),\quad \bar X_0=-1,\ \bar X_1=1,\ w_0=w_1=1,
$$

<p>Wz&#243;r Simpsona (parabol):</p>
$$
\int_{-1}^{1} g(X)dX \approx \frac{1}{3}\left(g(-1) + 4g(0)
+ g(1)\right),
$$

<p>gdzie</p>

$$
\bar X_0=-1,\ \bar X_1=0,\ \bar X_2=1,\ w_0=w_2=\frac{1}{3},\ w_1=\frac{4}{3}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="metoda-gaussa-legendre-a">Metoda Gaussa-Legendre'a  </h2>

<ul>
 <p><li> optymalne po&#322;o&#380;enie w&#281;z&#322;&#243;w kwadratury -> wy&#380;sza dok&#322;adno&#347;&#263;</li>
 <p><li> Kwadratury Gaussa-Legendre'a -> dobranie po&#322;o&#380;enia w&#281;z&#322;&#243;w oraz wag tak, aby ca&#322;kowa&#263; z jak najlepsz&#261; dok&#322;adno&#347;ci&#261;</li>
</ul>
$$
\begin{align}
M=1&:\quad \bar X_0=-\frac{1}{\sqrt{3}},\ 
\bar X_1=\frac{1}{\sqrt{3}},\ w_0=w_1=1
\label{_auto17}\\ 
M=2&:\quad \bar X_0=-\sqrt{\frac{3}{{5}}},\ \bar X_0=0,\ 
\bar X_2= \sqrt{\frac{3}{{5}}},\ w_0=w_2=\frac{5}{9},\ w_1=\frac{8}{9}
\label{_auto18}
\end{align}
$$


<ul>
 <p><li> \( M=1 \): dok&#322;adna dla wielomian&#243;w 3. stopnia</li>
 <p><li> \( M=2 \): dok&#322;adna dla wielomian&#243;w 5. stopnia</li> 
 <p><li> W og&#243;lno&#347;ci, \( M \)-punktowy wz&#243;r Gaussa-Legendre'a jest dok&#322;adny dla wielomian&#243;w stopnia \( 2M+1 \).</li>
</ul>
<p>Plik `numint.py zawiera zbi&#243;r w&#281;z&#322;&#243;w i wag dla metody Gaussa-Legendre'a.</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="fem:approx:2D">Aproksymacja funkcji w 2D</h1>

<div class="alert alert-block alert-notice alert-text-normal">
<b>Rozwini&#281;cie podej&#347;cia z 1D</b>
<p>
<p>Rozwi&#261;zania i algorytmy przedstawione dla aproksymacji funkcji \( f(x) \) w 1D
da si&#281; rozwin&#261;&#263; i ''przenie&#347;&#263;'' na przypadki funkcji \( f(x,y) \) w 2D i
 \( f(x,y,z) \) w 3D. Og&#243;lne wzory pozostaj&#261; takie same.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kr&#243;tkie-om&#243;wienie-zagadnienia-w-2d">Kr&#243;tkie om&#243;wienie zagadnienia w 2D </h2>

<p>Iloczyn skalarny w 2D:</p>

$$
(f,g) = \int_\Omega f(x,y)g(x,y) dx dy
$$

<p>Zastosowanie \( \LSM \) lub metody Galerkina da URL:</p>

$$
\begin{align*}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j)\\ 
b_i &= (f,\baspsi_i)
\end{align*}
$$

<p>Problem: Jak skonstruowa&#263; dwuwymiarowe funkcje bazowe \( \baspsi_i(x,y) \)?</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:2D:global">Funkcje bazowe 2D jako iloczyn tensorowy funkcji 1D</h2>

<p>Korzystaj&#261;c z funkcji bazowych 1D zmiennej \( x \)
oraz funkcji bazowych 1D zmiennej \( y \):
</p>

$$
\begin{align}
V_x &= \mbox{span}\{ \hat\baspsi_0(x),\ldots,\hat\baspsi_{N_x}(x)\}
\label{fem:approx:2D:Vx}\\ 
V_y &= \mbox{span}\{ \hat\baspsi_0(y),\ldots,\hat\baspsi_{N_y}(y)\}
\label{fem:approx:2D:Vy}
\end{align}
$$

<p>Przestrze&#324; wektorowa 2D mo&#380;e by&#263; zdefinowana jako <em>iloczyn tensorowy</em> 
 \( V = V_x\otimes V_y \) z funkcjami bazowymi:
</p>

$$
\baspsi_{p,q}(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y)
\quad p\in\Ix,q\in\Iy\tp
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="iloczyn-tensorowy">Iloczyn tensorowy </h2>

<p>Niech dane b&#281;d&#261; dwa wektory
\( a=(a_0,\ldots,a_M) \) i
\( b=(b_0,\ldots,b_N) \). Ich <em>zewn&#281;trznym iloczynem tensorowym</em>
(<a href="https://pl.wikipedia.org/wiki/Iloczyn_diadyczny" target="_self"> <em>iloczynem diadycznym</em> </a>
je&#347;li \( N=M \)) jest \( p=a\otimes b \) zdefiniowane jako:
</p>

$$ p_{i,j}=a_ib_j,\quad i=0,\ldots,M,\ j=0,\ldots,N\tp$$

<p>Uwaga: \( p \) to macierz/tablica dwuwymiarowa</p>

<p>Przyk&#322;ad: baza 2D jako iloczyn tensorowy przestrzeni 1D:</p>

$$ \baspsi_{p,q}(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
\quad p\in\Ix,q\in\Iy$$


<a href="https://pl.wikipedia.org/wiki/Iloczyn_Kroneckera" target="_self">iloczyn tensorowy macierzy</a>
<p>(dowolnych wymiar&#243;w)
->
</p>

<a href="https://pl.wikipedia.org/wiki/Iloczyn_Kroneckera#Iloczyn_tensorowy_wektor%C3%B3w" target="_self">iloczyn tensorowy wektor&#243;w</a>
<p>(dowolnych wymiar&#243;w)
->
</p>

<a href="https://pl.wikipedia.org/wiki/Iloczyn_diadyczny" target="_self">iloczyn diadyczny</a>
<p>(tego samego wymiaru)</p>

<a href="https://pl.wikipedia.org/wiki/Tensor" target="_self">tensor</a>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="r&#243;wnowa&#380;no&#347;&#263;-notacji-z-dwoma-lub-jednym-indeksem">R&#243;wnowa&#380;no&#347;&#263; notacji z dwoma lub jednym indeksem </h2>

<p>Baza przestrzeni 2D wymaga dw&#243;ch indeks&#243;w (i podw&#243;jnego sumowania) :</p>
$$ u = \sum_{p\in\Ix}\sum_{q\in\Iy} c_{p,q}\baspsi_{p,q}(x,y)
$$

<p>Lub tylko jednego indeksu</p>

$$ u = \sum_{j\in\If} c_j\baspsi_j(x,y)$$

<p>je&#347;li posiadamy odwzorowanie \( (p,q)\rightarrow i \):</p>

$$
\baspsi_i(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
\quad i=p (N_y+1) + q\hbox{ or } i=q (N_x+1) + p
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;adowa-baza-przestrzeni-2d-wzory">Przyk&#322;adowa baza przestrzeni 2D; wzory </h2>

<p>Dla dwuelementowej bazy 1D</p>

$$ \{ 1, x \} $$

<p>iloczyn tensorowy (wszystkie kombinacje) generuje baz&#281; przestrzeni 2D:</p>

$$ \baspsi_{0,0}=1,\quad \baspsi_{1,0}=x, \quad \baspsi_{0,1}=y,
\quad \baspsi_{1,1}=xy
$$

<p>W notacji jednoindeksowej:</p>

$$ \baspsi_0=1,\quad \baspsi_1=x, \quad \baspsi_2=y,\quad\baspsi_3 =xy
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;adowa-baza-przestrzeni-2d-zastosowanie">Przyk&#322;adowa baza przestrzeni 2D; zastosowanie </h2>
$$ \baspsi_0=1,\quad \baspsi_1=x, \quad \baspsi_2=y,\quad\baspsi_3 =xy
$$


$$
\int_0^{L_y} \int_0^{L_x}
\left\{
\left[
\begin{array}{cccc}
1\cdot 1 & 1 \cdot x  & 1 \cdot y & 1 \cdot xy  \\ 
x\cdot 1 & x \cdot x  & x \cdot y & x \cdot xy  \\ 
y\cdot 1 & y \cdot x  & y \cdot y & y \cdot xy  \\ 
xy\cdot 1 & xy \cdot x  & xy \cdot y & xy \cdot xy  
\end{array}
\right]
\left[
\begin{array}{c}
c_0 \\ 
c_1 \\ 
c_2 \\ 
c_3 
\end{array}
\right]
=
\left[
\begin{array}{c}
1\cdot f(x,y) \\ 
x\cdot f(x,y) \\ 
y\cdot f(x,y)  \\ 
xy\cdot f(x,y)   
\end{array}
\right]
\right\}
dxdy
$$

<p>Funkcja aproksymowana (kwadratowa) \( f(x,y) = (1+x^2)(1+2y^2) \) (po lewej),
funkcja aproksymuj&#261;ca (biliniowa) \( u \) (po prawej) (\( x^2y^2 \) vs \( xy \)):
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 58</p>
</center>
<p><img src="../fig/approx2D_bilinear.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:2D:global:code">Implementacja; principal changes to the 1D code</h2>

<p>Zmiany w kodzie w stosunku do wersji 1D (<code>approx1D.py</code>):</p>

<ul>
 <p><li> <code>Omega = [[0, L_x], [0, L_y]]</code></li>
 <p><li> Ca&#322;kowanie symboliczne w 2D</li>
 <p><li> Generowanie funkcji bazowych 2D (jako iloczyn&#243;w tensorowych)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="implementacja-2d-ca&#322;kowanie">Implementacja 2D: ca&#322;kowanie </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>

integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>psi[j]
I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand,
                 (x, Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]),
                 (y, Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]))

<span style="color: #408080; font-style: italic"># Fall back on numerical integration if symbolic integration</span>
<span style="color: #408080; font-style: italic"># was unsuccessful</span>
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
    integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x,y], integrand)
    I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand,
                       [Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
                       [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="implementacja-2d-funkcje-bazowe">Implementacja 2D: funkcje bazowe </h2>

<p>Iloczyn tensorowy bazy pot&#281;gowej \( x^i \) (bazy Taylora):</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">taylor</span>(x, y, Nx, Ny):
    <span style="color: #008000; font-weight: bold">return</span> [x<span style="color: #666666">**</span>i<span style="color: #666666">*</span>y<span style="color: #666666">**</span>j <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ny<span style="color: #666666">+1</span>)]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Iloczyn tensorowy bazy sinusoidalnej \( \sin((i+1)\pi x) \):</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sines</span>(x, y, Nx, Ny):
    <span style="color: #008000; font-weight: bold">return</span> [sym<span style="color: #666666">.</span>sin(sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin(sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>(j<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>y)
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ny<span style="color: #666666">+1</span>)]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Ca&#322;y kod w <code>approx2D.py</code>.</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="implementacja-2d-zastosowanie">Implementacja 2D: zastosowanie </h2>

\( f(x,y) = (1+x^2)(1+2y^2) \)


<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx2D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> (<span style="color: #666666">1+</span>x<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>(<span style="color: #666666">1+2*</span>y<span style="color: #666666">**2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> psi <span style="color: #666666">=</span> taylor(x, y, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> Omega <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">2</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">print</span> u
<span style="color: #666666">8*</span>x<span style="color: #666666">*</span>y <span style="color: #666666">-</span> <span style="color: #666666">2*</span>x<span style="color: #666666">/3</span> <span style="color: #666666">+</span> <span style="color: #666666">4*</span>y<span style="color: #666666">/3</span> <span style="color: #666666">-</span> <span style="color: #666666">1/9</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">print</span> sym<span style="color: #666666">.</span>expand(f)
<span style="color: #666666">2*</span>x<span style="color: #666666">**2*</span>y<span style="color: #666666">**2</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">1</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="implementacja-2d-przyk&#322;ad-zastosowanie-bazy-umo&#380;liwiaj&#261;cej-konstrukcj&#281;-rozwi&#261;zania-dok&#322;adnego">Implementacja 2D: przyk&#322;ad zastosowanie bazy umo&#380;liwiaj&#261;cej konstrukcj&#281; rozwi&#261;zania dok&#322;adnego </h2>

<p>Dodajemy funkcje bazowe o wy&#380;szych pot&#281;gach tak, aby \( f\in V \).
Spodziewany wynik: \( u=f \)
</p>


<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">&gt;&gt;&gt;</span> psi <span style="color: #666666">=</span> taylor(x, y, <span style="color: #666666">2</span>, <span style="color: #666666">2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">print</span> u
<span style="color: #666666">2*</span>x<span style="color: #666666">**2*</span>y<span style="color: #666666">**2</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>y<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">print</span> u<span style="color: #666666">-</span>f
<span style="color: #666666">0</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="fem:approx:3D:global">Uog&#243;lnienie do zagadnie&#324; 3D</h2>

<p>Kluczowa idea:</p>

$$ V = V_x\otimes V_y\otimes V_z$$

<div class="alert alert-block alert-notice alert-text-normal">
<b>Zastosowanie iloczynu tensorowego do wygenerowania bazy przestrzeni \( m \) wymiarowerj</b>
<p>
$$
\begin{align*}
a^{(q)} &= (a^{(q)}_0,\ldots,a^{(q)}_{N_q}),\quad q=0,\ldots,m\\ 
p &= a^{(0)}\otimes\cdots\otimes a^{(m)}\\ 
p_{i_0,i_1,\ldots,i_m} &= a^{(0)}_{i_1}a^{(1)}_{i_1}\cdots a^{(m)}_{i_m}
\end{align*}
$$
</div>

<p>W szczeg&#243;lno&#347;ci dla 3D:</p>

$$
\begin{align*}
\baspsi_{p,q,r}(x,y,z) &= \hat\baspsi_p(x)\hat\baspsi_q(y)\hat\baspsi_r(z)\\ 
u(x,y,z) &= \sum_{p\in\Ix}\sum_{q\in\Iy}\sum_{r\in\Iz} c_{p,q,r}
\baspsi_{p,q,r}(x,y,z)
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br>
<h1 id="elementy-sko&#324;czone-w-2d-i-3d">Elementy sko&#324;czone w 2D i 3D </h1>

<p>Zalety \( \FEM \) w zastosowaniach 2D i 3D:</p>

<ul>
  <p><li> &#322;atwo&#347;&#263; aproksymowania skomplikowanych geometrii</li>
  <p><li> &#322;atwo&#347;&#263; generowania wielomian&#243;w (funkcji bazowych) wy&#380;szych rz&#281;d&#243;w w celu zwi&#281;kszenia dok&#322;adno&#347;ci aproksymacji funkcji</li>
</ul>
<p>\( \FEM \) w 1D: g&#322;&#243;wnie dla cel&#243;w dydaktycznych, debugowania</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="przyk&#322;ady-kom&#243;rek-2d-i-3d">Przyk&#322;ady kom&#243;rek 2D i 3D </h2>

<p>2D:</p>

<ul>
 <p><li> tr&#243;jk&#261;ty (triangles)</li>
 <p><li> czworok&#261;ty (quadrilaterals)</li>
</ul>
<p>3D:</p>

<ul>
 <p><li> czworo&#347;ciany (tetrahedra)</li>
 <p><li> sze&#347;cio&#347;ciany (hexahedra)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obszar-prostok&#261;tny-2d-zbudowany-z-element&#243;w-typu-p1">Obszar prostok&#261;tny (2D) zbudowany z element&#243;w typu P1 </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 59</p>
</center>
<p><img src="../fig/mesh2D_rect_P1.png" width="800" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="nieregularny-obszar-2d-zbudowany-z-element&#243;w-typu-p1">Nieregularny obszar 2D zbudowany z element&#243;w typu P1 </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 60</p>
</center>
<p><img src="../fig/mesh2D_quarter_circle.png" width="600" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obszar-prostok&#261;tny-2d-zbudowany-z-element&#243;w-typu-q1">Obszar prostok&#261;tny (2D) zbudowany z element&#243;w typu Q1 </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 61</p>
</center>
<p><img src="../fig/mesh2D_rect_Q1.png" width="500" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="aproksymacja-funkcji-2d-na-siatce-element&#243;w-tr&#243;jk&#261;tnych">Aproksymacja funkcji 2D na siatce element&#243;w tr&#243;jk&#261;tnych </h2>

<p>Element tr&#243;jk&#261;tny typu P1: aproksymacja \( u \) na ka&#380;dym elemencie (kom&#243;rce)
funkcj&#261; liniow&#261; \( ax + by + c \)
</p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 62</p>
</center>
<p><img src="../fig/demo2D_4x3r.png" width="400" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="w&#322;asno&#347;ci-element&#243;w-2d-typu-p1">W&#322;asno&#347;ci element&#243;w 2D typu P1 </h2>

<ul>
 <p><li> Kom&#243;rki = tr&#243;jk&#261;ty</li>
 <p><li> Wierzcho&#322;ki = wierzcho&#322;ki kom&#243;rek</li>
 <p><li> w&#281;z&#322;y = wierzcho&#322;ki tr&#243;jk&#261;ta</li>
 <p><li> Stopnie swobody = warto&#347;ci funkcji w w&#281;z&#322;ach</li>
 <p><li> \( \refphi_r(X,Y) \) jest funkcj&#261; liniow&#261; na kom&#243;rce unormowanej</li>
 <p><li> \( \basphi_i(x,y) \) jest odzorowaniem \( \refphi_r(X,Y) \) na kom&#243;rce rzeczywistej</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="odwzorowanie-liniowe-elementu-unormowanego-na-kom&#243;rk&#281;-tr&#243;jk&#261;tn&#261;">Odwzorowanie liniowe elementu unormowanego na kom&#243;rk&#281; tr&#243;jk&#261;tn&#261; </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 63</p>
</center>
<p><img src="../fig/ElmT3n2D_map.png" width="400" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="basphi-i-funkcja-piramida">\( \basphi_i \): funkcja-piramida </h2>

<ul>
 <p><li> \( \basphi_i(x,y) \) &ndash; zmienno&#347;&#263; liniowa na poszczeg&#243;lnych kom&#243;rkach</li>
 <p><li> \( \basphi_i=1 \) w wierzcho&#322;ku (w&#281;&#378;le) \( i \), 0 w pozosta&#322;ych wierzcho&#322;kach (w&#281;z&#322;ach)</li>
</ul>
<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 64</p>
</center>
<p><img src="../fig/demo2D_basisfunc.png" width="400" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="elementy-macierzy-i-wektora-prawej-strony">Elementy macierzy i wektora prawej strony </h2>

<ul>
 <p><li> Jak w 1D, wk&#322;ad pojedynczej kom&#243;rki do macierzy globalnego URL ogranicza si&#281; do kilku warto&#347;ci w macierzy i wektorze wyraz&#243;w wolnych</li>
 <p><li> \( \basphi_i\basphi_j\neq 0 \) wtedy i tylko wtedy gdy \( i \) oraz \( j \) s&#261; stopniami swobody (wierzcho&#322;kami/w&#281;z&#322;ami) na tym samym elemencie</li>
 <p><li> Lokalna macierz tr&#243;jk&#261;tengo elementu P1 to macierz o rozmiarach \( 3\times 3 \)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="funkcje-bazowe-na-unormowanym-elemencie-tr&#243;jk&#261;tnym">Funkcje bazowe na unormowanym elemencie tr&#243;jk&#261;tnym </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 65</p>
</center>
<p><img src="../fig/fenics-book/elements/P1_2d.png" width="100" align="bottom"></p>
</center>

$$
\begin{align}
\refphi_0(X,Y) &= 1 - X - Y
\label{_auto19}\\ 
\refphi_1(X,Y) &= X
\label{_auto20}\\ 
\refphi_2(X,Y) &= Y
\label{_auto21}
\end{align}
$$

<p>Funkcje bazowe \( \refphi_r \) wy&#380;szych stopni opieraj&#261; si&#281; na
wi&#281;kszej liczbie w&#281;z&#322;&#243;w (stopni swobody)
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="elementy-tr&#243;jk&#261;tne-typu-p1-p2-p3-p4-p5-p6-przestrzeni-2d">Elementy tr&#243;jk&#261;tne typu P1, P2, P3, P4, P5, P6 przestrzeni 2D </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 66</p>
</center>
<p><img src="../fig/fenics-book/elements/P1-6_2d.png" width="320" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="elementy-p1-przestrzeni-1d-2d-i-3d">Elementy P1 przestrzeni 1D, 2D i 3D </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 67</p>
</center>
<p><img src="../fig/fenics-book/elements/P1-1d2d3d.png" width="320" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="elementy-p2-przestrzeni-1d-2d-i-3d">Elementy P2 przestrzeni 1D, 2D i 3D </h2>


<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 68</p>
</center>
<p><img src="../fig/fenics-book/elements/P2-1d2d3d.png" width="320" align="bottom"></p>
</center>

<ul>
 <p><li> Interval, triangle, tetrahedron: <em>sympleksy</em> (ang. <em>simplex</em> -> *simplices*/*simplexes*)</li>
 <p><li> <em>&#347;ciana</em> (ang. <em>face</em>) &ndash; bok kom&#243;rki (&#347;cianka/krawed&#378;/punkt)</li>
 <p><li> W czworo&#347;cianie r&#243;wnie&#380; <em>kraw&#281;dzie</em> (<em>edges</em>)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="odwzorowanie-afiniczne-kom&#243;rki-unormowanej-ndash-wz&#243;r">Odwzorowanie afiniczne kom&#243;rki unormowanej &ndash; wz&#243;r </h2>

<p>Transformacja (Odwzorowanie) kom&#243;rki we wsp&#243;&#322;rz&#281;dnych unormowanych</p>

\( \X = (X,Y) \)

<p>do kom&#243;rki we wsp&#243;&#322;rz&#281;dnych globalnych:</p>

\( \x = (x,y) \):

$$
\begin{equation}
\x = \sum_{r} \refphi_r^{(1)}(\X)\xdno{q(e,r)}
\label{fem:approx:fe:affine:map}
\end{equation}
$$

<p>gdzie</p>

<ul>
  <p><li> \( r \) przebiega przez wszystkie wierzcho&#322;ki kom&#243;rki</li>
  <p><li> \( \xdno{i} \) to globalne wsp&#243;&#322;rz&#281;dne \( (x,y) \) wierzcho&#322;ka \( i \)</li>
  <p><li> \( \refphi_r^{(1)} \) to funkcja bazowa typu P1</li>
</ul>
<p>Odwzorowanie zachowuje liniowo&#347;&#263; &#347;cian i kraw&#281;dzi.</p>

<ul>
<p><li> TODO (Przyk&#322;ad rachunkowy)</li>
</ul>
<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="odwzorowanie-afiniczne-kom&#243;rki-unormowanej">Odwzorowanie afiniczne kom&#243;rki unormowanej </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 69</p>
</center>
<p><img src="../fig/ElmT3n2D_map.png" width="400" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="kom&#243;rki-izoparametryczne">Kom&#243;rki izoparametryczne </h2>

<p>Idea: Wykorzystanie funkcji bazowych elementu (nie tylko funkcji typu P1 ale
i wy&#380;szych rz&#281;d&#243;w) do odwzorowania geometrii:
</p>

$$
\x = \sum_{r} \refphi_r(\X)\xdno{q(e,r)}
$$

<p>Zaleta: pozwala generowa&#263; elementy o geomtrii <em>nielinowej</em></p>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 70</p>
</center>
<p><img src="../fig/ElmT6n2D_map.png" width="400" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="obliczanie-ca&#322;ek">Obliczanie ca&#322;ek </h2>

<p>Wymagana transformacja ca&#322;ek z \( \Omega^{(e)} \) (kom&#243;rka we wsp&#243;&#322;rz&#261;dnych globalnych)
w \( \tilde\Omega^r \) (kom&#243;rka unormowana/odniesienia):
</p>

$$
\begin{align}
\int_{\Omega^{(e)}}\basphi_i (\x) \basphi_j (\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) \refphi_j (\X)
\det J\, \dX
\label{_auto22}\\ 
\int_{\Omega^{(e)}}\basphi_i (\x) f(\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) f(\x(\X)) \det J\, \dX
\label{_auto23}
\end{align}
$$

<p>gdzie \( \dx = dx dy \) lub \( \dx = dxdydz \) oraz \( \det J \) to wyznacznik
jakobianu odwzorowania \( \x(\X) \).
</p>

$$
J = \left[\begin{array}{cc}
\frac{\partial x}{\partial X} & \frac{\partial x}{\partial Y}\\ 
\frac{\partial y}{\partial X} & \frac{\partial y}{\partial Y}
\end{array}\right], \quad
\det J = \frac{\partial x}{\partial X}\frac{\partial y}{\partial Y}
- \frac{\partial x}{\partial Y}\frac{\partial y}{\partial X}
$$

<p>Odwzorowanie afiniczne
\eqref{fem:approx:fe:affine:map}:
\( \det J=2\Delta \), \( \Delta = \hbox{powierzchnia kom&#243;rki/elementu} \)
</p>

<!-- !split --><br><br><br><br><br><br><br><br>
<h2 id="uwaga-dot-uog&#243;lnienia-fem-z-1d-do-2d-3d">Uwaga dot. uog&#243;lnienia FEM z 1D do 2D/3D </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Og&#243;lna idea \( \FEM \) oraz kroki algorytmu &ndash; takie same niezale&#380;nie
od wymiarowo&#347;ci geometrii.
</p>

<p>Im wy&#380;szy wymiar przestrzeni, tym wi&#281;kszy nak&#322;ad obliczeniowy.
ze wzgl&#281;du na komplikacj&#281; wzor&#243;w.
</p>

<p>Obliczenia r&#281;czne - nu&#380;&#261;ce, podatne na pope&#322;nienie pomy&#322;ki.</p>

<p>Automatyzacja i algorytmizacja problemu po&#380;&#261;dana.</p>
</div>

<!-- ------------------- end of main content --------------- -->
</body>
</html>

